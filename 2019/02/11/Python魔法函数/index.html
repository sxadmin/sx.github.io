<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Python魔法函数 | Sxadmin blog</title><meta name="description" content="Python的特性之一，魔法函数，即具有优秀功能的内置函数，通常作用在自定义的类中，用来完成业务所需要的数据结构类型等等。"><meta name="keywords" content="魔法函数"><meta name="author" content="Sxadmin"><meta name="copyright" content="Sxadmin"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://s1.ax1x.com/2020/06/15/NpA1v6.th.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Python魔法函数"><meta name="twitter:description" content="Python的特性之一，魔法函数，即具有优秀功能的内置函数，通常作用在自定义的类中，用来完成业务所需要的数据结构类型等等。"><meta name="twitter:image" content="https://sxadmin.github.io/img/cover/cover32.png"><meta property="og:type" content="article"><meta property="og:title" content="Python魔法函数"><meta property="og:url" content="https://sxadmin.github.io/2019/02/11/Python%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/"><meta property="og:site_name" content="Sxadmin blog"><meta property="og:description" content="Python的特性之一，魔法函数，即具有优秀功能的内置函数，通常作用在自定义的类中，用来完成业务所需要的数据结构类型等等。"><meta property="og:image" content="https://sxadmin.github.io/img/cover/cover32.png"><meta property="article:published_time" content="2019-02-11T08:24:50.000Z"><meta property="article:modified_time" content="2020-06-14T17:58:09.000Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://sxadmin.github.io/2019/02/11/Python%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/"><link rel="prev" title="PyQt5简要" href="https://sxadmin.github.io/2019/02/25/PyQt5%E7%AE%80%E8%A6%81/"><link rel="next" title="Python一切皆对象" href="https://sxadmin.github.io/2019/02/08/Python%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='https://s1.ax1x.com/2020/06/15/NpPYfx.jpg'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">92</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">64</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 關於</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#魔法函数概念"><span class="toc-number">1.</span> <span class="toc-text">魔法函数概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#魔法函数对类的影响"><span class="toc-number">2.</span> <span class="toc-text">魔法函数对类的影响</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内置魔法函数"><span class="toc-number">3.</span> <span class="toc-text">内置魔法函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串表示"><span class="toc-number">3.1.</span> <span class="toc-text">字符串表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合序列"><span class="toc-number">3.2.</span> <span class="toc-text">集合序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代"><span class="toc-number">3.3.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可调用"><span class="toc-number">3.4.</span> <span class="toc-text">可调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#with上下文管理"><span class="toc-number">3.5.</span> <span class="toc-text">with上下文管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#enter"><span class="toc-number">3.5.1.</span> <span class="toc-text">__enter__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exit"><span class="toc-number">3.5.2.</span> <span class="toc-text">__exit__</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数值转换"><span class="toc-number">3.6.</span> <span class="toc-text">数值转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#元类相关"><span class="toc-number">3.7.</span> <span class="toc-text">元类相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性相关"><span class="toc-number">3.8.</span> <span class="toc-text">属性相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性描述符"><span class="toc-number">3.9.</span> <span class="toc-text">属性描述符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协程"><span class="toc-number">3.10.</span> <span class="toc-text">协程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#梳理"><span class="toc-number">4.</span> <span class="toc-text">梳理</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/cover/cover32.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Sxadmin blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 關於</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Python魔法函数</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-02-11 16:24:50"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-02-11</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-15 01:58:09"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-15</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python%E9%AB%98%E9%98%B6%E7%AC%94%E8%AE%B0/">Python高阶笔记</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote class="blockquote-center">优有价值的人在任何时代都会被尊重。</blockquote>

<script type="text/javascript" src="/js/src/bai.js"></script>

<h1 id="魔法函数概念"><a href="#魔法函数概念" class="headerlink" title="魔法函数概念"></a>魔法函数概念</h1><p>魔法函数是以双下划线开头并且以双下划线结尾的功能函数，可以用来定义自己类的新特性。</p>
<p>举一个例子：</p>
<pre><code>class magic:
    def __init__(self,num):
        self.num = num

    def __getitem__(self, item):
        return self.num[item]

a = magic([&apos;1&apos;,&apos;2&apos;,&apos;3&apos;])
for x in a:
    print x</code></pre><p>返回结果：</p>
<pre><code>1
2
3</code></pre><p>简直鹅妹子嘤！</p>
<p>这里的__getitem__是魔法函数中的其中一个，具有的功能是返回一个有序化数组的值。在定义的类magic中，你引用了一个魔法函数，这个magic类就拥有了该魔法函数的功能。</p>
<p>当使用for循环的时候，因为getitem基于你的magic类一个可迭代的功能，所以magic类具有可迭代功能。</p>
<h1 id="魔法函数对类的影响"><a href="#魔法函数对类的影响" class="headerlink" title="魔法函数对类的影响"></a>魔法函数对类的影响</h1><p>如上若是，仅仅在类中添加了getitem这个魔法函数，就能直接使用for循环，也就是说魔法函数在一定程度上可以影响python自定义类的语法，或者说是增强了你这个类的类型。</p>
<p>通过python内置的大量魔法函数，你可以创造出具有独特个性的数据类型，符合业务的需求。</p>
<p>举个例子：</p>
<pre><code>class magic:
    &apos;&apos;&apos;
    这是功能性注释
    使用__doc__就可以看到啦
    &apos;&apos;&apos;
    def __init__(self,num):
        self.num = num

    def __len__(self):
        return 6666666

a = magic(5)
print len(a)
print a.__doc__ </code></pre><p>返回结果：</p>
<pre><code>6666666

    这是功能性注释
    使用__doc__就可以看到啦</code></pre><p>通过魔法函数__len__实现获取，len本来是获取字符串或者列表数量长度，但是通过自定义类就实现了返回6666666.</p>
<h1 id="内置魔法函数"><a href="#内置魔法函数" class="headerlink" title="内置魔法函数"></a>内置魔法函数</h1><p>python中内置了大量的魔法函数，尝试理解和记下这些魔法函数在以后的业务需求中可以如鱼得水，所以说还是要背啊~~</p>
<h2 id="字符串表示"><a href="#字符串表示" class="headerlink" title="字符串表示"></a>字符串表示</h2><pre><code>1. __repr__ 格式化字符串式样，主用开发模式下
2. __str__    常用的字符串，格式化字符串</code></pre><p>这连个魔法函数的作用都是和字符串相关，一般来说在print打印中会调用这个魔法函数</p>
<pre><code>class magic:
    def __init__(self,num):
        self.num = num

    def __str__(self):
        return (self.num + &apos;\n&apos;)*5

a = magic(&apos;浪子好帅啊&apos;)
print a</code></pre><p>输出结果：</p>
<pre><code>浪子好帅啊
浪子好帅啊
浪子好帅啊
浪子好帅啊
浪子好帅啊</code></pre><p>这里使用print a和使用 print a.__str__()效果是一样的。同理repr(a)和a.__repr__</p>
<p>区别：</p>
<pre><code>__repr__ 目的是为了表示清楚，是为开发者准备的。

__str__ 目的是可读性好，是为使用者准备的。

__repr__ 应该尽可能的表示出一个对象来源的类以及继承关系，方便程序员们了解这个对象。而 __str__ 就简单的表示对象，而不要让不懂编程的以为输出的是 bug。</code></pre><p>同时定义 <strong>repr</strong> 方法和 <strong>str</strong> 方法时，print() 方法会调用 <strong>str</strong> 方法。</p>
<p><a href="https://blog.csdn.net/sinat_41104353/article/details/79254149" target="_blank" rel="noopener">参考解析</a></p>
<h2 id="集合序列"><a href="#集合序列" class="headerlink" title="集合序列"></a>集合序列</h2><pre><code>1. __len__
2. __getitem__
3. __setitem__
4. __delitem__
5. __contains__</code></pre><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><pre><code>1. __iter__
2. __next__</code></pre><p>在存储数据的数据结构中有list，set，tuple，dict，当使用for循环他们的时候，本质上是做了两件事。</p>
<ol>
<li>获得一个迭代对象，调用__iter__魔法函数</li>
<li>循环的时候，循环调用__next__魔法函数</li>
</ol>
<p>举个例子：</p>
<pre><code>class magic:
    def __init__(self,num):
        self.num = num

    def __iter__(self):
        # 使用__iter__，magic类就变成了可迭代对象
        return self

    def __next__(self):
        # __next__魔法函数的作用是在循环的时候，无限提供输出下一个值，直到没有数据后抛出异常
        if self.num &gt;5:
            # 设置上限
            raise StopIteration
        else:
            self.num += 1
            return self.num

a = magic(-5)
for x in a:
    print(x)</code></pre><p>返回结果：</p>
<pre><code>-4
-3
-2
-1
0
1
2
3
4
5
6</code></pre><p>可能有些难理解，这是第一次自己做出来的一个数据类型，他的作用是提供一个原始值，自增长到6就停止。</p>
<p>如果这样做也可以的：</p>
<pre><code>a = magic(-5)
print(a.__next__())
print(next(a))</code></pre><p>返回结果：</p>
<pre><code>-4
-3</code></pre><p>总的来说，使用iter魔法函数，这个类就变成了可迭代对象，但是如何调用这个可迭代对象的数值呢？这个时候就需要使用next来循环调用了。</p>
<p>注意：含有<em>\</em>next__()函数的对象都是一个迭代器(Iterator)，也就是说__next__要继承Iterator,__iter__要继承Iterable，继承的类来自与collections</p>
<p><a href="https://sxadmin.github.io/Python%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1.html">迭代器与可迭代对象</a></p>
<p><a href="https://blog.csdn.net/liweibin1994/article/details/77374854" target="_blank" rel="noopener">参考解析</a></p>
<h2 id="可调用"><a href="#可调用" class="headerlink" title="可调用"></a>可调用</h2><pre><code>1. __call__</code></pre><p>一个类实例变成一个可调用对象，只需要实现一个特殊方法__call__()。在创建类的时候，只要使用了call这个魔法函数，那么这个类就是可调用的。</p>
<p>函数之所以可以被直接调用，原因在于他的底层是用call实现的。</p>
<p>举个例子：</p>
<pre><code>class magic:
    def __init__(self):
        pass
    def __call__(self, num):
        return &apos;浪子:&apos; + num

a = magic()
print(a(&apos;admin&apos;))</code></pre><p>运行结果：</p>
<pre><code>浪子:admin</code></pre><p>可以看到结果直接运行出来了。这样的例子不够深刻，尝试把场景转移到业务需求中来。</p>
<p>浪子餐馆卖馒头，每次买出一个，店小二就会大喊’xxx买了一个馒头<del>花了1块钱</del>‘</p>
<p>使用类来实现：</p>
<pre><code>class ao:
    def __init__(self,name):
        self.name =name

    def __call__(self, money):
        return self.name + &apos;大老板买了一个馒头~~花了%s元~~让我们感谢这位老铁~~&apos;%money

a = ao(&apos;小桃红&apos;)
print(a(15))
b = ao(&apos;猫饼饼&apos;)
print(b(666))</code></pre><p>运行结果：</p>
<pre><code>小桃红大老板买了一个馒头~~花了15元~~让我们感谢这位老铁~~
猫饼饼大老板买了一个馒头~~花了666元~~让我们感谢这位老铁~~</code></pre><p>总的来说，就是你定义类中只要有call，那么就可以直接调用，注意call是对象不是类。他和new以及init的关系如下(可以先不看)</p>
<ol>
<li><p><strong>new</strong>： 对象的创建，是一个静态方法，第一个参数是cls。(想想也是，不可能是self，对象还没创建，哪来的self)</p>
</li>
<li><p><strong>init</strong> ： 对象的初始化， 是一个实例方法，第一个参数是self。</p>
</li>
<li><p><strong>call</strong> ： 对象可call，注意不是类，是对象。</p>
</li>
</ol>
<p>问题：为了让下面这段代码运行，需要增加哪些代码？</p>
<pre><code>class A(object):
    def __init__(self,a,b):
        self.__a = a
        self.__b = b
    def myprint(self):
        print &apos;a=&apos;, self.__a, &apos;b=&apos;, self.__b


a1=A(10,20)
a1.myprint()

a1(80)</code></pre><p>为了能让对象实例能被直接调用，需要实现<strong>call</strong>方法</p>
<pre><code>class A(object):
    def __init__(self,a,b):
        self.__a = a
        self.__b = b
    def myprint(self):
        print(&apos;a=&apos;, self.__a, &apos;b=&apos;, self.__b)
    def __call__(self, *args, **kwargs):
        print(args)</code></pre><h2 id="with上下文管理"><a href="#with上下文管理" class="headerlink" title="with上下文管理"></a>with上下文管理</h2><pre><code>1. __enter__
2. __exit__</code></pre><p>with上下文管理器，对于那些需要必须成对打开关闭的操作是非常方便的，比如打开关闭文件。他的实现原理就是通过enter和exit这两个魔法函数来实现的。</p>
<p>先看看常规的实现一个with上下文管理器的步骤，Pymysql with 操作<a href="https://sxadmin.github.io/Flask%20SQLAlchemy%20%E6%95%B0%E6%8D%AE%E5%BA%93.html">来源</a></p>
<pre><code>import contextlib
@contextlib.contextmanager
def mysql(host=&apos;127.0.0.1&apos;,user=&apos;root&apos;,passwd=&apos;root&apos;,db=&apos;meizi&apos;,port=3306,charset=&apos;utf8&apos;):
    conn = pymysql.connect(host=&apos;127.0.0.1&apos;,user=&apos;root&apos;,passwd=&apos;root&apos;,db=&apos;meizi&apos;,port=3306,charset=&apos;utf8&apos;)
    cursor = conn.cursor()
    try:
        yield cursor
    finally:
        conn.commit()
        cursor.close()
        conn.close()
# # 执行sql
# with mysql() as cursor:
#    print(cursor)
#    row_count = cursor.execute(&quot;select * from tb7&quot;)
#    row_1 = cursor.fetchone()
#    print row_count, row_1</code></pre><p>想要自己实现这种类的话，就必须要使用到enter和exit这两个魔法函数。</p>
<p>比如上面的 </p>
<pre><code>with mysql() as cursor</code></pre><p>把步骤分析一下：</p>
<ol>
<li>当with的后面mysql()函数被执行的时候，对象的enter方法被调用</li>
<li>函数主动发起数据库连接，获取一个游标</li>
<li>随后使用yield生成器寄存这个游标</li>
<li>这个游标被赋值给as后面的cursor</li>
<li>当with后面的代码全都执行完毕后，调用前面返回对象的exit方法</li>
</ol>
<p>举个例子：</p>
<pre><code>class magic:
    def __enter__(self):
        print(&apos;enter魔法函数执行&apos;)
        return &apos;enter魔法函数执行完毕&apos;
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&apos;exti魔法函数执行&apos;)
        return &apos;exit魔法函数执行完毕&apos;

def ma():
    return magic()

with ma() as a:
    print(&apos;随便执行一些东西&apos;)</code></pre><p>运行结果：</p>
<pre><code>enter魔法函数执行
随便执行一些东西
exti魔法函数执行</code></pre><p>是不是想到了装饰器？通过查看contextlib库的源码发现导入了wrapper装饰器，说到装饰器你是不是你又想到了闭包？然后又想到了变量的作用域？</p>
<p>是的，这些知识都是一个完整的体系，相互串联。</p>
<p>还没结束，继续深入分析。</p>
<p>在exit魔法函数的值中的含义</p>
<pre><code>exc_type:异常类(如果抛出异常,这里获取异常的类型 )
exc_value:异常实例(如果抛出异常,这里显示异常内容)
exc_tb:异常位置(如果抛出异常,这里显示所在位置)
traceback:追溯对象()</code></pre><p>因为with操作本身就是为了简写try/finally操作的。</p>
<p>比如在熟悉的with操作文本文件一样，打开文件是放在enter函数中，关闭文件放在exit函数中。</p>
<p>with真正强大之处是它不仅可以完善的管理上下文，同时还可以处理异常。</p>
<h3 id="enter"><a href="#enter" class="headerlink" title="__enter__"></a>__enter__</h3><p>__enter__ 用于赋值给 as 后面的变量。不过 with 语句中 as 不是必须的。__enter__ 和 __exit__ 必须并用。</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="__exit__"></a>__exit__</h3><p>用于捕获异常，它的返回值是一个 boolean 对象。除了 self 之外，必须传入另外三个参数，分别表示 exception 的类型，值（如 IndexError: list index out of range 中，冒号后面的部分就是值），以及 traceback。</p>
<p>返回 True 则表示这个异常被忽略。</p>
<p>返回 None, False 等则这个异常会抛出。</p>
<p>如果要忽略所有的异常可以这样写：</p>
<pre><code>def __exit__(self, exc_type, exc_value, traceback):
    return True</code></pre><p>经过测试， SyntaxError 是不能忽略的，其他已知的是可以的。</p>
<p><a href="https://www.jianshu.com/p/fc25fe7d7cf2" target="_blank" rel="noopener">参考链接</a></p>
<h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><pre><code>1. __abs__
2. __bool__
3. __int__
4. __float__
5. __hash__
6. __index__</code></pre><h2 id="元类相关"><a href="#元类相关" class="headerlink" title="元类相关"></a>元类相关</h2><pre><code>1. __new__
2. __init__</code></pre><p>说到init你会想到创建类的时候实例的对象，但是new是啥？</p>
<p>依照Python官方文档的说法，__new__方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的metaclass。</p>
<p>是不是感觉有点迷？没关系，用例子来说明就好了。</p>
<pre><code>class magic(object):
    def __init__(self,nums):
        self.nums = nums
        print &apos;666&apos;
        print &apos;init:&apos; + self.nums

    def __new__(cls, nums):
        cls.nums = nums
        print &apos;new:&apos;+cls.nums

a = magic(&apos;A&apos;)</code></pre><p>返回结果：</p>
<pre><code>new:A</code></pre><p>这里看到只输出了new的对象，并且注意magic类继承了object，在上一篇文章中有说道，元类(即类的类)都必须要继承自object，因为记住了，继承自object的新类才有__new__</p>
<p>重新修改一下代码，让init也执行下呢？</p>
<pre><code>class magic(object):
    def __init__(self,nums):
        self.nums = nums
        print &apos;666&apos;
        print &apos;init:&apos; + self.nums

    def __new__(cls, nums):
        cls.nums = nums
        print &apos;new:&apos;+cls.nums
        # 执行到这里会打印内容
        return object.__new__(cls)
        # 这里会返回一个内容
        # 返回的内容会传递到init中的self中去
a = magic(&apos;A&apos;)</code></pre><p>返回结果：</p>
<pre><code>new:A
666
init:A</code></pre><p>大家注意看，这里返回了object的new方法，然后init就执行了，这证明上面说的，new会先于init执行，并且new方法返回的值就是init方法中的self。</p>
<p>继续举例子：</p>
<pre><code>class magic(object):
    def __init__(self,nums):
        self.nums = self.nums
        self.langzi = &apos;langzi&apos;
        print &apos;666&apos;
        print &apos;init:&apos; + self.nums

    def __new__(cls, nums):
        print nums
        # 这里打印出传递进来的数值
        cls.nums = nums+&apos;BCDEFG&apos;
        cls.langzi = &apos;浪子&apos;
        print &apos;new:&apos;+cls.nums
        return object.__new__(cls)


a = magic(&apos;A&apos;)
print &apos;-&apos;*10
print a.langzi
print a.nums</code></pre><p>先猜一猜会输出什么呢？</p>
<p>返回结果：</p>
<pre><code>A
new:ABCDEFG
666
init:ABCDEFG
----------
langzi
ABCDEFG</code></pre><p>来分析一下</p>
<ol>
<li>打印传递进来的A</li>
<li>随后赋值给cls.nums，打印new:ABCDEFG，同时定义cls.langzi=浪子</li>
<li>继续执行，new方法返回object对象，这个时候会执行到init</li>
<li>这里的self其实就是new中返回的对象</li>
<li>然后定义self.nums和self.langzi=langzi(这个时候这个类的langzi对象就变成了langzi,不再是浪子)</li>
<li>打印666</li>
<li>打印出init:ABCDEFG</li>
<li>打印—————-</li>
<li>验证这个类中的属性值a.langzi和a.nums</li>
</ol>
<p>通过分析这个实例步骤，来进一步研究new和init的关系：</p>
<p>通过上面代码的执行结果我们可以发现程序首先执行了<strong>new</strong>，之后执行的<strong>init</strong>，这说明，在类中，如果<strong>new</strong>和<strong>init</strong>同时存在会优先调用<strong>new</strong>。</p>
<p><strong>new</strong>方法会返回所构造的对象，<strong>init</strong>则不会。<strong>init</strong>无返回值。</p>
<p><strong>new</strong>至少要有一个参数cls，代表要实例化的类(类对象)，此参数在实例化时由Python解释器自动提供。</p>
<p><strong>new</strong>必须要有返回值，返回实例化出来的实例，这点在自己实现，<strong>new</strong>时要特别注意，可以return父类<strong>new</strong>出来的实例或者直接是object的<strong>new</strong>出来的实例。</p>
<p><strong>init</strong>有一个参数self，就是这个<strong>new</strong>返回的实例，<strong>init</strong>在<strong>new</strong>的基础上可以完成一些其它初始化的动作，<strong>init</strong>不需要返回值</p>
<p>我们可以将类比作制造商，<strong>new</strong>方法就是前期的原材料购买环节，<strong>init</strong>方法就是在有原材料的基础上，加工，初始化商品环节</p>
<p>总而言之就是：</p>
<ol>
<li>new:创建对象时调用，会返回当前对象的一个实例，new是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例，是个静态方法，常用于允许继承不可变类型（str，int， tuple）</li>
<li>init:创建完对象后调用，对当前对象的一些实例初始化，无返回值，init是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值。</li>
<li>new是控制对象的生成过程，init是完善对象，如果new方法不返回对象，则不会调用init魔法函数。</li>
</ol>
<p>下面这段代码输出什么？</p>
<pre><code>class B(object):
    def fn(self):
        print &apos;B fn&apos;
    def __init__(self):
        print &quot;B INIT&quot;


class A(object):
    def fn(self):
        print &apos;A fn&apos;

    def __new__(cls,a):
            print &quot;NEW&quot;, a
            if a&gt;10:
                return super(A, cls).__new__(cls)
            return B()

    def __init__(self,a):
        print &quot;INIT&quot;, a

a1 = A(5)
a1.fn()
a2=A(20)
a2.fn()</code></pre><p>返回结果：</p>
<pre><code>NEW 5
B INIT
B fn
NEW 20
INIT 20
A fn</code></pre><p>使用<strong>new</strong>方法，可以决定返回那个对象，也就是创建对象之前，这个可以用于设计模式的单例、工厂模式。<strong>init</strong>是创建对象是调用的。</p>
<p><a href="https://blog.csdn.net/syl625393441/article/details/82789104" target="_blank" rel="noopener">参考链接1</a></p>
<p><a href="https://blog.csdn.net/qq_41637554/article/details/81048453" target="_blank" rel="noopener">参考链接2</a></p>
<h2 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h2><pre><code>1. __getattr__,__setattr__
2. __getattribute__,setattribute__
3. __dir__</code></pre><h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><pre><code>1. __get__,__set__,__delete__</code></pre><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><pre><code>1. __await__
2. __aiter__
3. __anext__
4. __aenter__
5. __aexit__</code></pre><p>这个是最重要也是最难的，以后慢慢说。</p>
<h1 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h1><ol>
<li>魔法函数是python内置的，具有双下划线开头结尾的特性。</li>
<li>自定义的类中使用魔法函数，该类就具有了该魔法函数的功能，比如使用iter魔法函数，该类就具有迭代功能。</li>
<li>使用魔法函数实现高灵活性，实现自己所需要的独特的数据类型。</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Sxadmin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sxadmin.github.io/2019/02/11/Python%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/">https://sxadmin.github.io/2019/02/11/Python%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sxadmin.github.io" target="_blank">Sxadmin blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/">魔法函数</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover43.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/02/25/PyQt5%E7%AE%80%E8%A6%81/"><img class="prev_cover" src="/img/cover/cover92.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">PyQt5简要</div></div></a></div><div class="next-post pull_right"><a href="/2019/02/08/Python%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/"><img class="next_cover" src="/img/cover/cover74.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python一切皆对象</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Sxadmin</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Asyncio并发编程 | Sxadmin blog</title><meta name="description" content="Python高并发框架，进一步解读asyncio的语法与功能，同时对支持异步的web网络请求包aiohttp功能做介绍。"><meta name="keywords" content="Asyncio"><meta name="author" content="Sxadmin"><meta name="copyright" content="Sxadmin"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://s1.ax1x.com/2020/06/15/NpA1v6.th.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Asyncio并发编程"><meta name="twitter:description" content="Python高并发框架，进一步解读asyncio的语法与功能，同时对支持异步的web网络请求包aiohttp功能做介绍。"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Asyncio并发编程"><meta property="og:url" content="https://sxadmin.github.io/2019/04/03/Asyncio%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="Sxadmin blog"><meta property="og:description" content="Python高并发框架，进一步解读asyncio的语法与功能，同时对支持异步的web网络请求包aiohttp功能做介绍。"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2019-04-03T06:09:24.000Z"><meta property="article:modified_time" content="2020-02-10T13:36:36.652Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://sxadmin.github.io/2019/04/03/Asyncio%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><link rel="prev" title="Django-快速上手" href="https://sxadmin.github.io/2019/07/03/Django-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"><link rel="next" title="Python打包exe文件方法" href="https://sxadmin.github.io/2019/03/07/Python%E6%89%93%E5%8C%85exe%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='https://s1.ax1x.com/2020/06/15/NpPYfx.jpg'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">83</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">57</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 關於</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Asyncio"><span class="toc-number">1.</span> <span class="toc-text">Asyncio</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#事件循环"><span class="toc-number">1.1.</span> <span class="toc-text">事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单案例-访问一个网站"><span class="toc-number">1.1.1.</span> <span class="toc-text">简单案例(访问一个网站)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单案例-访问多个网站"><span class="toc-number">1.1.2.</span> <span class="toc-text">简单案例(访问多个网站)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单案例-获取返回值"><span class="toc-number">1.1.3.</span> <span class="toc-text">简单案例(获取返回值)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单案例-回调函数"><span class="toc-number">1.1.4.</span> <span class="toc-text">简单案例(回调函数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#梳理"><span class="toc-number">1.1.5.</span> <span class="toc-text">梳理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#取消协程任务"><span class="toc-number">1.2.</span> <span class="toc-text">取消协程任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#梳理-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">梳理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协程相互嵌套"><span class="toc-number">1.3.</span> <span class="toc-text">协程相互嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定时启动任务"><span class="toc-number">1.4.</span> <span class="toc-text">定时启动任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#call-soon"><span class="toc-number">1.4.1.</span> <span class="toc-text">call_soon</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-later"><span class="toc-number">1.4.2.</span> <span class="toc-text">call_later</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-at"><span class="toc-number">1.4.3.</span> <span class="toc-text">call_at</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-soon-threadsafe-线程安全的call-soon"><span class="toc-number">1.4.4.</span> <span class="toc-text">call_soon_threadsafe 线程安全的call_soon</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#梳理-2"><span class="toc-number">1.4.5.</span> <span class="toc-text">梳理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结合线程池"><span class="toc-number">1.5.</span> <span class="toc-text">结合线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用requests完成异步编程-使用线程池"><span class="toc-number">1.5.1.</span> <span class="toc-text">用requests完成异步编程(使用线程池)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用socket完成异步编程-使用线程池"><span class="toc-number">1.5.2.</span> <span class="toc-text">### 用socket完成异步编程(使用线程池)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用socket完成http请求-未使用线程池"><span class="toc-number">1.5.3.</span> <span class="toc-text">使用socket完成http请求(未使用线程池)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#梳理-3"><span class="toc-number">1.5.4.</span> <span class="toc-text">梳理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与多进程的结合"><span class="toc-number">1.6.</span> <span class="toc-text">与多进程的结合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步与通信"><span class="toc-number">1.7.</span> <span class="toc-text">同步与通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单例子-顺序启动多任务"><span class="toc-number">1.7.1.</span> <span class="toc-text">简单例子(顺序启动多任务)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单例子-Lock-锁"><span class="toc-number">1.7.2.</span> <span class="toc-text">简单例子(Lock(锁))</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单例子-Semaphore-信号量"><span class="toc-number">1.7.3.</span> <span class="toc-text">简单例子(Semaphore(信号量))</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单例子-Condition-条件"><span class="toc-number">1.7.4.</span> <span class="toc-text">简单例子(Condition(条件))</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单例子-Event-事件"><span class="toc-number">1.7.5.</span> <span class="toc-text">简单例子(Event(事件))</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单例子-协程间通信"><span class="toc-number">1.7.6.</span> <span class="toc-text">简单例子(协程间通信)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加速asyncio"><span class="toc-number">1.8.</span> <span class="toc-text">加速asyncio</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Aiohttp"><span class="toc-number">2.</span> <span class="toc-text">Aiohttp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#aiohttp基础用法"><span class="toc-number">2.1.</span> <span class="toc-text">aiohttp基础用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aiohttp安装"><span class="toc-number">2.2.</span> <span class="toc-text">aiohttp安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本请求用法"><span class="toc-number">2.3.</span> <span class="toc-text">基本请求用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发起一个session请求"><span class="toc-number">2.4.</span> <span class="toc-text">发起一个session请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在URL中传递参数"><span class="toc-number">2.5.</span> <span class="toc-text">在URL中传递参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应的内容"><span class="toc-number">2.6.</span> <span class="toc-text">响应的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特殊响应内容：json"><span class="toc-number">2.7.</span> <span class="toc-text">特殊响应内容：json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#以字节流的方式读取响应内容"><span class="toc-number">2.8.</span> <span class="toc-text">以字节流的方式读取响应内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义请求头"><span class="toc-number">2.9.</span> <span class="toc-text">自定义请求头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义Cookie"><span class="toc-number">2.10.</span> <span class="toc-text">自定义Cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#忽略SSL证书"><span class="toc-number">2.11.</span> <span class="toc-text">忽略SSL证书</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSL加密请求"><span class="toc-number">2.12.</span> <span class="toc-text">SSL加密请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#限制同时请求数量"><span class="toc-number">2.13.</span> <span class="toc-text">限制同时请求数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#post数据的几种方式"><span class="toc-number">2.14.</span> <span class="toc-text">post数据的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive-连接池，共享cookie"><span class="toc-number">2.15.</span> <span class="toc-text">keep-alive, 连接池，共享cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie安全性"><span class="toc-number">2.16.</span> <span class="toc-text">cookie安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#控制同时连接的数量（连接池）"><span class="toc-number">2.17.</span> <span class="toc-text">控制同时连接的数量（连接池）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义域名解析"><span class="toc-number">2.18.</span> <span class="toc-text">自定义域名解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设置代理"><span class="toc-number">2.19.</span> <span class="toc-text">设置代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应状态码-response-status-code"><span class="toc-number">2.20.</span> <span class="toc-text">响应状态码 response status code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应头"><span class="toc-number">2.21.</span> <span class="toc-text">响应头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重定向的响应头"><span class="toc-number">2.22.</span> <span class="toc-text">重定向的响应头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#超时处理"><span class="toc-number">2.23.</span> <span class="toc-text">超时处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他优秀的AIO库"><span class="toc-number">3.</span> <span class="toc-text">其他优秀的AIO库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#aio-mysql"><span class="toc-number">3.1.</span> <span class="toc-text">aio_mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖"><span class="toc-number">3.1.1.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基础用法"><span class="toc-number">3.1.2.</span> <span class="toc-text">基础用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连接池"><span class="toc-number">3.1.3.</span> <span class="toc-text">连接池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aioredis"><span class="toc-number">3.2.</span> <span class="toc-text">aioredis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基础用法-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">基础用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连接池-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">连接池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aiomultiprocess"><span class="toc-number">3.3.</span> <span class="toc-text">aiomultiprocess</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基础用法-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">基础用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取返回结果"><span class="toc-number">3.3.3.</span> <span class="toc-text">获取返回结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池管理"><span class="toc-number">3.3.4.</span> <span class="toc-text">线程池管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对传参控制"><span class="toc-number">3.3.5.</span> <span class="toc-text">对传参控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aiofiles"><span class="toc-number">3.4.</span> <span class="toc-text">aiofiles</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础用法-3"><span class="toc-number">3.4.1.</span> <span class="toc-text">基础用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aiodns"><span class="toc-number">3.5.</span> <span class="toc-text">Aiodns</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础用法-4"><span class="toc-number">3.5.1.</span> <span class="toc-text">基础用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncSSH"><span class="toc-number">3.6.</span> <span class="toc-text">AsyncSSH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖-3"><span class="toc-number">3.6.1.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基础用法-5"><span class="toc-number">3.6.2.</span> <span class="toc-text">基础用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#janus"><span class="toc-number">3.7.</span> <span class="toc-text">janus</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础用法-6"><span class="toc-number">3.7.1.</span> <span class="toc-text">基础用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aioelasticsearch"><span class="toc-number">3.8.</span> <span class="toc-text">aioelasticsearch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基础用法-7"><span class="toc-number">3.8.1.</span> <span class="toc-text">基础用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步滚动"><span class="toc-number">3.8.2.</span> <span class="toc-text">异步滚动</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Sxadmin blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 關於</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Asyncio并发编程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-04-03 14:09:24"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-04-03</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-02-10 21:36:36"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-02-10</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python%E9%AB%98%E9%98%B6%E7%AC%94%E8%AE%B0/">Python高阶笔记</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote class="blockquote-center">我喜欢铁路，你沿着铁路走，在尽头肯定会找到一座城市，或者其他什么有人的地方。不像鸟飞在空中，甚至不知道前面会不会有目的地。</blockquote>

<script type="text/javascript" src="/js/src/bai.js"></script>

<h1 id="Asyncio"><a href="#Asyncio" class="headerlink" title="Asyncio"></a>Asyncio</h1><p>在python3.5之前，都是使用生成器的一些技巧完成协程任务，他们的调度方式依然是 事件循环+协程模式。这样设计结构和维护虽然相对于回调函数简单一些，但是代码还是有一些混乱，并且又当作生成器又当作协程，都是还是一些技巧性的东西，为了将语义变得更加明确，于是在python3.5使用了async和await(功能与yield from类似)关键词正式定义原生协程，asyncio是python解决异步io编程的一个完整框架。</p>
<p>它具有如下定义：</p>
<ol>
<li>包含各种特定系统实现的模块化事件循环</li>
<li>传输与协议抽象</li>
<li>对TCP,UDP,SSL,子进程，延时调用以及其他的具体支持</li>
<li>模仿futures模块适用于事件循环使用到Future类</li>
<li>基于yield from的协议和任务，可以使用顺序执行的方式编写并发代码</li>
<li>必须使用一个将产生阻塞IO的调用时，有接口可以把这个事件转移到线程池</li>
<li>模仿threading模块中的同步语法，可以用在单线程内实现协程同步</li>
</ol>
<p>协程编程离不开的三大要点：</p>
<ol>
<li>事件循环</li>
<li>回调(驱动生成器)</li>
<li>epoll/select(IO多路复用)</li>
</ol>
<p>Asyncio是一个异步编程的框架，可以解决异步编程，协程调度问题，线程问题，是整个异步IO的解决方案。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><h3 id="简单案例-访问一个网站"><a href="#简单案例-访问一个网站" class="headerlink" title="简单案例(访问一个网站)"></a>简单案例(访问一个网站)</h3><pre><code>async def get_url_title(url):
# 使用关键词async定义一个协程
    print(&apos;开始访问网站:{}&apos;.format(url))
    await asyncio.sleep(2)
    # 这一步至关重要
    # asyncio.sleep(2) 功能:异步非阻塞等待2s，作用是模拟访问网站消耗的时间
    # await 的作用类似 yield，即这个时候把线程资源控制权交出去,监听这个描述符直到这个任务完成
    # await 后面只能接三种类型
    &apos;&apos;&apos;
    1. 协程:Python 协程属于 可等待 对象，因此可以在其他协程中被等待:
    2. 任务:任务 被用来设置日程以便 并发 执行协程。(当一个协程通过 asyncio.create_task() 等函数被打包为一个 任务，该协程将自动排入日程准备立即运行)
    3. Future 对象:Future 是一种特殊的 低层级 可等待对象，表示一个异步操作的 最终结果。(当一个 Future 对象 被等待，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。)

    如果await time.sleep(2) 是会报错的
    &apos;&apos;&apos;
    print(&apos;网站访问成功&apos;)

if __name__ == &apos;__main__&apos;:
    start_time = time.time()
    loop = asyncio.get_event_loop()
    # 一行代码创造事件循环
    loop.run_until_complete(get_url_title(&apos;https://sxadmin.github.io&apos;))
    # 这是一个阻塞的方法,可以理解成多线程中的join方法
    # 直到get_url_title(&apos;https://sxadmin.github.io&apos;)完成后，才会继续执行下面的代码
    end_time = time.time()
    print(&apos;消耗时间:{}&apos;.format(end_time-start_time))</code></pre><p>返回结果：</p>
<pre><code>开始访问网站:https://sxadmin.github.io
网站访问成功
消耗时间:2.0018768310546875</code></pre><h3 id="简单案例-访问多个网站"><a href="#简单案例-访问多个网站" class="headerlink" title="简单案例(访问多个网站)"></a>简单案例(访问多个网站)</h3><p>协程的优势是多任务协作，单任务访问网站没法发挥出他的功能，一次性访问多个网站或者一次性等待多个IO响应时间才能发挥它的优势。</p>
<pre><code># -*- coding:utf-8 -*-
import asyncio
import time

async def get_url_title(url):
    print(&apos;开始访问网站:{}&apos;.format(url))
    await asyncio.sleep(2)
    print(&apos;网站访问成功&apos;)

if __name__ == &apos;__main__&apos;:
    start_time = time.time()
    loop = asyncio.get_event_loop()
    # 创造一个事件循环
    tasks = [get_url_title(&apos;https://sxadmin.github.io&apos;)for i in range(10)]
    # 这个列表代表总任务量，即执行10次get_url_title()函数
    loop.run_until_complete(asyncio.wait(tasks))
    # asyncio.wait后面接上非空可迭代对象,一般来说是功能函数列表
    # 功能是一次性提交多个任务，等待完成
    # loop.run_until_complete(asyncio.gather(*tasks))
    # 和上面代码功能一致，但是gather更加高级，如果是列表就需要加上*
    # 这里会等到全部的任务执行完后才会执行后面的代码
    end_time = time.time()
    print(&apos;消耗时间:{}&apos;.format(end_time-start_time))</code></pre><p>对一个网站发起10次请求，返回结果：</p>
<pre><code>开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
消耗时间:2.0015649795532227</code></pre><p>gather与wait的区别：</p>
<ul>
<li>gather更擅长于将函数聚合在一起</li>
<li>wait更擅长筛选运行状况</li>
</ul>
<p>即gather更加高级，他可以将任务分组，也可以取消任务</p>
<pre><code>import asyncio

async def get_url_title(url):
    print(&apos;开始访问网站:{}&apos;.format(url))
    await asyncio.sleep(2)
    print(&apos;网站访问成功&apos;)
    return &apos;success&apos;

if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    # 使用wait方法
    # tasks = [get_url_title(&apos;https://sxadmin.github.io&apos;)for i in range(10)]
    # loop.run_until_complete(asyncio.wait(tasks))

    # 使用gather方法实现分组导入(方法1)
    group1 = [get_url_title(&apos;https://sxadmin.github.io&apos;)for i in range(3)]
    group2 = [get_url_title(&apos;http://www.baidu.com&apos;)for i in range(5)]
    loop.run_until_complete(asyncio.gather(*group1,*group2))
    # 这种方法会把两个全部一次性导入

    # 使用gather方法实现分组导入(方法2)
    group1 = [get_url_title(&apos;https://sxadmin.github.io&apos;)for i in range(3)]
    group2 = [get_url_title(&apos;http://www.baidu.com&apos;)for i in range(5)]
    group1 = asyncio.gather(*group1)
    group2 = asyncio.gather(*group2)
    #group2.cancel() 取消group2任务
    loop.run_until_complete(asyncio.gather(group1,group2))
    # 这种方法会先把group1导入，然后导入group2</code></pre><p>返回结果：</p>
<pre><code>开始访问网站:http://www.baidu.com
开始访问网站:http://www.baidu.com
开始访问网站:https://sxadmin.github.io
开始访问网站:http://www.baidu.com
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:http://www.baidu.com
开始访问网站:http://www.baidu.com
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:http://www.baidu.com
开始访问网站:http://www.baidu.com
开始访问网站:http://www.baidu.com
开始访问网站:http://www.baidu.com
开始访问网站:http://www.baidu.com
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功</code></pre><p>另外一种使用gather获取返回结果:</p>
<pre><code>import asyncio

async def get_url_title(url):
    print(&apos;开始访问网站:{}&apos;.format(url))
    await asyncio.sleep(2)
    print(&apos;网站访问成功&apos;)
    return &apos;success&apos;

if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    # 使用gather方法传递任务获取结果
    group1 = asyncio.ensure_future(get_url_title(&apos;https://sxadmin.github.io&apos;))
    loop.run_until_complete(asyncio.gather(group1))
    # 如果不是列表就不需要加*
    print(group1.result())</code></pre><p>返回结果：</p>
<pre><code>开始访问网站:https://sxadmin.github.io
网站访问成功
success</code></pre><h3 id="简单案例-获取返回值"><a href="#简单案例-获取返回值" class="headerlink" title="简单案例(获取返回值)"></a>简单案例(获取返回值)</h3><pre><code># -*- coding:utf-8 -*-
import asyncio
import time

async def get_url_title(url):
    print(&apos;开始访问网站:{}&apos;.format(url))
    await asyncio.sleep(2)
    print(&apos;网站访问成功&apos;)
    return &apos;success&apos;

if __name__ == &apos;__main__&apos;:
    start_time = time.time()
    loop = asyncio.get_event_loop()
    # 创建一个事件循环

    get_future = loop.create_task(get_url_title(&apos;https://sxadmin.github.io&apos;))
    #get_future = asyncio.ensure_future(get_url_title(&apos;https://sxadmin.github.io&apos;))
    # 这两行代码功能用法一模一样

    loop.run_until_complete(get_future)
    print(&apos;获取结果:{}&apos;.format(get_future.result()))
    # 获取结果

    end_time = time.time()
    print(&apos;消耗时间:{}&apos;.format(end_time-start_time))</code></pre><p>返回结果：</p>
<pre><code>开始访问网站:https://sxadmin.github.io
网站访问成功
获取结果:success
消耗时间:2.0019724369049072</code></pre><p>如果是多个网址传入，访问多个网址的返回值呢？只需要把前面的知识点汇总一起即可使用：</p>
<pre><code>if __name__ == &apos;__main__&apos;:
    start_time = time.time()
    loop = asyncio.get_event_loop()
    # 创建一个事件循环

    tasks = [loop.create_task(get_url_title(&apos;https://sxadmin.github.io&apos;)) for i in range(10)]
    # 把所有要返回的函数加载到一个列表

    loop.run_until_complete(asyncio.wait(tasks))
    # 这里和上面用法一样

    print(&apos;获取结果:{}&apos;.format([x.result() for x in tasks]))
    # 因为结果都在一个列表，在列表中取值即可

    end_time = time.time()
    print(&apos;消耗时间:{}&apos;.format(end_time-start_time))</code></pre><p>返回结果：</p>
<pre><code>开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
开始访问网站:https://sxadmin.github.io
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
网站访问成功
获取结果:[&apos;success&apos;, &apos;success&apos;, &apos;success&apos;, &apos;success&apos;, &apos;success&apos;, &apos;success&apos;, &apos;success&apos;, &apos;success&apos;, &apos;success&apos;, &apos;success&apos;]
消耗时间:2.0016491413116455</code></pre><h3 id="简单案例-回调函数"><a href="#简单案例-回调函数" class="headerlink" title="简单案例(回调函数)"></a>简单案例(回调函数)</h3><p>上面的例子是一个协程函数，当这个协程函数的await xxx执行完毕后，想要执行另一个函数后，然后再返回这个协程函数的返回结果该这么做：</p>
<pre><code># -*- coding:utf-8 -*-
import asyncio
from functools import partial
# partial的功能是 固定函数参数，返回一个新的函数。你可以这么理解：
&apos;&apos;&apos;
from functools import partial
    def go(x,y):
        return x+y
    g = partial(go,y=2)
    print(g(1))
返回结果：3

    g = partial(go,x=5,y=2)
    print(g())
返回结果：7

&apos;&apos;&apos;
async def get_url_title(url):
    print(&apos;开始访问网站:{}&apos;.format(url))
    await asyncio.sleep(2)
    print(&apos;网站访问成功&apos;)
    # 当这个协程函数快要结束返回值的时候，会调用下面的call_back函数
    # 等待call_back函数执行完毕后，才返回这个协程函数的值
    return &apos;success&apos;

def call_back(future,url):
    # 注意这里必须要传递future参数，因为这里的future即代表下面的get_future对象
    print(&apos;检测网址:{}状态正常&apos;.format(url))

if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    # 创建一个事件循环

    get_future = loop.create_task(get_url_title(&apos;https://sxadmin.github.io&apos;))
    # 将一个任务注册到loop事件循环中

    get_future.add_done_callback(partial(call_back,url = &apos;https://sxadmin.github.io&apos;))
    # 这里是设置，当上面的任务完成要返回结果的时候，执行call_back函数
    # 注意call_back函数不能加上()，也就意味着你只能依靠partial方法进行传递参数

    loop.run_until_complete(get_future)
    # 等待任务完成
    print(&apos;获取结果:{}&apos;.format(get_future.result()))
    # 获取结果</code></pre><p>返回结果：</p>
<pre><code>开始访问网站:https://sxadmin.github.io
网站访问成功
检测网址:https://sxadmin.github.io状态正常
获取结果:success</code></pre><h3 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h3><ol>
<li>协程函数必须要使用关键词async定义</li>
<li>如果遇到了要等待的对象，必须要使用await</li>
<li>使用await后面的任务，必须是可等待对象(三种主要类型: 协程, 任务 和 Future.)</li>
<li>运行前，必须要创建一个事件循环(loop = asyncio.get_event_loop(),一行代码即可)</li>
<li>然后把任务加载到该事件循环中即可</li>
<li>如果需要获取协程函数的返回值，需要使用loop.create_task()或asyncio.ensure_future()函数，在最后使用.result()获取返回结果。</li>
<li>如果想要把多个任务注册到loop中，需要使用一个列表包含他们，调用的时候使用asyncio.wait(list)</li>
</ol>
<h2 id="取消协程任务"><a href="#取消协程任务" class="headerlink" title="取消协程任务"></a>取消协程任务</h2><p>存在多个任务协程，想使用ctrl c退出协程，使用例子讲解：</p>
<pre><code>import asyncio
async def get_time_sleep(t):
    print(&apos;开始运行，等待:{}s&apos;.format(t))
    await asyncio.sleep(t)
    print(&apos;运行结束&apos;)

if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    # 创建一个事件循环
    task_1 = get_time_sleep(1)
    task_2 = get_time_sleep(2)
    task_3 = get_time_sleep(3)

    tasks = [task_1,task_2,task_3]
    # 三个协程任务加载到一个列表

    try:
        loop.run_until_complete(asyncio.wait(tasks))
    except KeyboardInterrupt:
        # 当检测到键盘输入 ctrl c的时候
        all_tasks = asyncio.Task.all_tasks()
        # 获取注册到loop下的所有task
        for task in all_tasks:
            print(&apos;开始取消协程&apos;)
            task.cancel()
            # 取消该协程,如果取消成功则返回True
        loop.stop()
        # 停止循环
        loop.run_forever()
        # loop事件循环一直运行
        # 这两步必须要做
    finally:
        loop.close()
        # 关闭事件循环</code></pre><p>run_forever 会一直运行，直到 stop 被调用，但是你不能像下面这样调 stop</p>
<pre><code>loop.run_forever()
loop.stop()</code></pre><p>run_forever 不返回，stop 永远也不会被调用。所以，只能在协程中调 stop：</p>
<pre><code>async def do_some_work(loop, x):
    print(&apos;Waiting &apos; + str(x))
    await asyncio.sleep(x)
    print(&apos;Done&apos;)
    loop.stop()</code></pre><p>这样并非没有问题，假如有多个协程在 loop 里运行：</p>
<pre><code>asyncio.ensure_future(do_some_work(loop, 1))
asyncio.ensure_future(do_some_work(loop, 3))

loop.run_forever()</code></pre><p>第二个协程没结束，loop 就停止了——被先结束的那个协程给停掉的。<br>要解决这个问题，可以用 gather 把多个协程合并成一个 future，并添加回调，然后在回调里再去停止 loop。</p>
<pre><code>async def do_some_work(loop, x):
    print(&apos;Waiting &apos; + str(x))
    await asyncio.sleep(x)
    print(&apos;Done&apos;)

def done_callback(loop, futu):
    loop.stop()

loop = asyncio.get_event_loop()

futus = asyncio.gather(do_some_work(loop, 1), do_some_work(loop, 3))
futus.add_done_callback(functools.partial(done_callback, loop))

loop.run_forever()</code></pre><p>其实这基本上就是 run_until_complete 的实现了，run_until_complete 在内部也是调用 run_forever。</p>
<p>关于loop.close()，简单来说，loop 只要不关闭，就还可以再运行。</p>
<pre><code>loop.run_until_complete(do_some_work(loop, 1))
loop.run_until_complete(do_some_work(loop, 3))
loop.close()</code></pre><p>但是如果关闭了，就不能再运行了：</p>
<pre><code>loop.run_until_complete(do_some_work(loop, 1))
loop.close()
loop.run_until_complete(do_some_work(loop, 3))  # 此处异常</code></pre><h3 id="梳理-1"><a href="#梳理-1" class="headerlink" title="梳理"></a>梳理</h3><ol>
<li>通过gather()启动的协程任务，是可以直接取消的，并且还能获取取消是否成功</li>
<li>可以通过 asyncio.Task.all_tasks()获取所有的协程任务</li>
<li>如果使用run_forever()的话会一直运行，只能通过loop.stop()停止</li>
</ol>
<h2 id="协程相互嵌套"><a href="#协程相互嵌套" class="headerlink" title="协程相互嵌套"></a>协程相互嵌套</h2><pre><code>import asyncio
async def sum_tion(x,y):
    print(&apos;开始执行传入参数相加:{} + {}&apos;.format(x,y))
    await asyncio.sleep(1)
    # 模拟等待1S
    return (x+y)

async def print_sum(x,y):
    result = await sum_tion(x,y)
    print(result)

if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()

    loop.run_until_complete(print_sum(1000,2000))

    loop.close()</code></pre><p>返回结果：</p>
<pre><code>开始执行传入参数相加:1000 + 2000
3000</code></pre><p>执行流程：</p>
<ol>
<li>run_until_complete运行，会注册task（协程：print_sum）并开启事件循环 </li>
<li>print_sum协程中嵌套了子协程，此时print_sum协程暂停（类似委托生成器），转到子协程（协程：sum_tion）中运行代码，期间子协程需sleep1秒钟，直接将结果反馈到event loop中，即将控制权转回调用方，而中间的print_sum暂停不操作 </li>
<li>1秒后，调用方将控制权给到子协程（调用方与子协程直接通信），子协程执行接下来的代码，直到再遇到wait（此实例没有）</li>
<li>最后执行到return语句，子协程向上级协程（print_sum抛出异常：StopIteration），同时将return返回的值返回给上级协程（print_sum中的result接收值），print_sum继续执行暂时时后续的代码，直到遇到return语句 </li>
<li>向 event loop 抛出StopIteration异常，此时协程任务都已经执行完毕，事件循环执行完成（event loop ：the loop is stopped），close事件循环。</li>
</ol>
<p>如果想要获取协程嵌套函数返回的值，就必须使用回调：</p>
<pre><code>import asyncio
async def sum_tion(x,y)-&gt;int:
    print(&apos;开始执行传入参数相加:{} + {}&apos;.format(x,y))
    await asyncio.sleep(1)
    # 模拟等待1S
    return (x+y)

async def print_sum(x,y):
    result = await sum_tion(x,y)
    return result

def callback(future):
    return future.result()

if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()

    future = loop.create_task(print_sum(100,200))
    # 如果想要获取嵌套协程返回的值，就必须使用回调

    future.add_done_callback(callback)
    loop.run_until_complete(future)

    print(future.result())

    loop.close()</code></pre><p>返回结果：</p>
<pre><code>开始执行传入参数相加:100 + 200
300</code></pre><h2 id="定时启动任务"><a href="#定时启动任务" class="headerlink" title="定时启动任务"></a>定时启动任务</h2><p>asyncio提供定时启动协程任务，通过call_soon,call_later,call_at实现，他们的区别如下：</p>
<h3 id="call-soon"><a href="#call-soon" class="headerlink" title="call_soon"></a>call_soon</h3><p>call_soon是立即执行</p>
<pre><code>def callback(sleep_times):
    print(&quot;预计消耗时间 {} s&quot;.format(sleep_times))
def stoploop(loop):
    print(&apos;时间消耗完毕&apos;)
    loop.stop()


if __name__ == &quot;__main__&quot;:
    start_time = time.time()
    loop = asyncio.get_event_loop()
    # 创建一个事件循环
    loop.call_soon(callback,5)
    # 立即启动callback函数
    loop.call_soon(stoploop,loop)
    # 上面执行完毕后，立即启动执行stoploop函数
    loop.run_forever()
    #要用这个run_forever运行，因为没有传入协程
    print(&apos;总共耗时:{}&apos;.format(time.time()-start_time))</code></pre><p>返回结果：</p>
<pre><code>预计消耗时间 5 s
时间消耗完毕
总共耗时:0.0010013580322265625</code></pre><h3 id="call-later"><a href="#call-later" class="headerlink" title="call_later"></a>call_later</h3><p>call_later是设置一定时间启动执行</p>
<pre><code>def callback(sleep_times):
    print(&quot;预计消耗时间 {} s&quot;.format(sleep_times))
def stoploop(loop):
    print(&apos;时间消耗完毕&apos;)
    loop.stop()


if __name__ == &quot;__main__&quot;:
    start_time = time.time()
    loop = asyncio.get_event_loop()


    loop.call_later(1,callback,1.0)
    # 等待1秒后执行callback函数，传入参数是1.0
    loop.call_later(5,stoploop,loop)
    # 等待5秒后执行stoploop函数，传入参数是loop

    loop.run_forever()
    print(&apos;总共耗时:{}&apos;.format(time.time()-start_time))</code></pre><p>返回结果：</p>
<pre><code>预计消耗时间 1.0 s
时间消耗完毕
总共耗时:5.002613544464111</code></pre><h3 id="call-at"><a href="#call-at" class="headerlink" title="call_at"></a>call_at</h3><p>call_at类似与call_later，但是他指定的时间不再是传统意义上的时间，而是loop的内部时钟时间，效果和call_later一样， call_later内部其实调用了call_later</p>
<pre><code>import time
import asyncio

def callback(loop):
    print(&quot;传入loop.time()时间为: {} s&quot;.format(loop.time()))
def stoploop(loop):
    print(&apos;时间消耗完毕&apos;)
    loop.stop()


if __name__ == &quot;__main__&quot;:
    start_time = time.time()
    loop = asyncio.get_event_loop()

    now = loop.time()
    # loop内部的时钟时间
    loop.call_at(now+1,callback,loop)
    # 等待loop内部时钟时间加上1s后，执行callba函数，传入参数为loop
    loop.call_at(now+3,callback,loop)
    # 等待loop内部时钟时间加上3s后，执行callba函数，传入参数为loop
    loop.call_at(now+5,stoploop,loop)
    # 等待loop内部时钟时间加上1s后，执行stoploop函数，传入参数为loop</code></pre><p>返回结果:</p>
<pre><code>传入loop.time()时间为: 3989.39 s
传入loop.time()时间为: 3991.39 s
时间消耗完毕
总共耗时:5.002060174942017</code></pre><h3 id="call-soon-threadsafe-线程安全的call-soon"><a href="#call-soon-threadsafe-线程安全的call-soon" class="headerlink" title="call_soon_threadsafe 线程安全的call_soon"></a>call_soon_threadsafe 线程安全的call_soon</h3><p>call_soon_threadsafe用法和call_soon一致。但在涉及多线程时， 会使用它.</p>
<h3 id="梳理-2"><a href="#梳理-2" class="headerlink" title="梳理"></a>梳理</h3><ol>
<li>call_soon直接启动</li>
<li>call_later自己定时启动</li>
<li>call_at根据loop.time()内部的时间，设置等待时间启动</li>
<li>call_soon_threadsafe和call_soon方法一致，是保证线程安全的</li>
<li>他们都是比较底层的，在正常使用时很少用到。</li>
</ol>
<h2 id="结合线程池"><a href="#结合线程池" class="headerlink" title="结合线程池"></a>结合线程池</h2><p>Asyncio是异步IO编程的解决方案，异步IO是包括多线程，多进程，和协程的。所以asyncio是可以完成多线程多进程和协程的，在开头说到，协程是单线程的，如果遇到阻塞的话，会阻塞所有的代码任务，所以是不能加入阻塞IO的，但是比如requests库是阻塞的，socket如果不设置setblocking(false)的话，也是阻塞的，这个时候可以放到一个线程中去做也是可以解决的，即在协程中集成阻塞IO，就加入多线程一起解决问题。</p>
<h3 id="用requests完成异步编程-使用线程池"><a href="#用requests完成异步编程-使用线程池" class="headerlink" title="用requests完成异步编程(使用线程池)"></a>用requests完成异步编程(使用线程池)</h3><pre><code>from concurrent.futures import ThreadPoolExecutor
import requests
import asyncio
import time
import re

def get_url_title(url):
    # 功能是获取网址的标题
    r = requests.get(url)
    try:
        title = re.search(&apos;&lt;title&gt;(.*?)&lt;/title&gt;&apos;,r.content.decode(),re.S|re.I).group(1)
    except Exception as e:
        title = e
    print(title)

if __name__ == &apos;__main__&apos;:
    start_time = time.time()

    loop = asyncio.get_event_loop()
    # 创建一个事件循环
    p = ThreadPoolExecutor(5)
    # 创建一个线程池，开启5个线程
    tasks = [loop.run_in_executor(p,get_url_title,&apos;https://sxadmin.github.io&apos;)for i in range(10)]
    # 这一步很重要，使用loop.run_in_executor()函数:内部接受的是阻塞的线程池，执行的函数，传入的参数
    # 即对网站访问10次，使用线程池访问
    loop.run_until_complete(asyncio.wait(tasks))
    # 等待所有的任务完成
    print(time.time()-start_time)</code></pre><p>返回结果：</p>
<pre><code> Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
5.589502334594727</code></pre><p>访问10次消耗时间为5.5s，尝试将 p = ThreadPoolExecutor(10)，线程数量设置成10个线程，消耗时间为4.6s，改用从进程池p = ProcessPoolExecutor(10)，也是一样可以运行的，不过10个进程消耗时间也是5.5s，并且消耗更多的CPU资源。</p>
<h3 id="用socket完成异步编程-使用线程池"><a href="#用socket完成异步编程-使用线程池" class="headerlink" title="### 用socket完成异步编程(使用线程池)"></a>### 用socket完成异步编程(使用线程池)</h3><pre><code>import asyncio
from concurrent.futures import ThreadPoolExecutor
import socket
from urllib.parse import urlparse
import time
import re


def get_url(url):
    # 通过socket请求html
    url = urlparse(url)
    host = url.netloc
    path = url.path
    if path == &quot;&quot;:
        path = &apos;/&apos;

    # 建立socket连接
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.connect((host, 80))
    client.send(
        &quot;GET {} HTTP/1.1\r\nHost:{}\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode(&apos;utf8&apos;))
    data = b&quot;&quot;
    while True:
        d = client.recv(1024)
        if d:
            data += d
        else:
            break
    data = data.decode(&apos;utf8&apos;)
    html_data = data.split(&apos;\r\n\r\n&apos;)[1]
    # 把请求头信息去掉， 只要网页内容
    title = re.search(&apos;&lt;title&gt;(.*?)&lt;/title&gt;&apos;,html_data,re.S|re.I).group(1)
    print(title)
    client.close()


if __name__ == &apos;__main__&apos;:
    start_time = time.time()
    loop = asyncio.get_event_loop()
    p = ThreadPoolExecutor(3)  # 线程池 放3个线程
    tasks = [loop.run_in_executor(p,get_url,&apos;https://sxadmin.github.io&apos;) for i in range(10)]
    loop.run_until_complete(asyncio.wait(tasks))
    print(&apos;last time:{}&apos;.format(time.time() - start_time))</code></pre><p>返回结果：</p>
<pre><code> Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
 Langzi - Never Setter 永不将就 - 致力于Python开发网络安全工具,分享Python底层与进阶知识，漏洞扫描器开发与爬虫开发 
last time:5.132313966751099</code></pre><h3 id="使用socket完成http请求-未使用线程池"><a href="#使用socket完成http请求-未使用线程池" class="headerlink" title="使用socket完成http请求(未使用线程池)"></a>使用socket完成http请求(未使用线程池)</h3><pre><code>import asyncio
from urllib.parse import urlparse
import time


async def get_url(url):
    # 通过socket请求html
    url = urlparse(url)
    host = url.netloc
    path = url.path
    if path == &quot;&quot;:
        path = &apos;/&apos;

    # 建立socket连接
    reader, writer = await asyncio.open_connection(host, 80)  # 协程 与服务端建立连接
    writer.write(
        &quot;GET {} HTTP/1.1\r\nHost:{}\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode(&apos;utf8&apos;))
    all_lines = []
    async for raw_line in reader:  # __aiter__ __anext__魔法方法
        line = raw_line.decode(&apos;utf8&apos;)
        all_lines.append(line)
    html = &apos;\n&apos;.join(all_lines)
    return html


async def main():
    tasks = []
    tasks = [asyncio.ensure_future(get_url(&apos;https://sxadmin.github.io&apos;)) for i in range(10)]
    for task in asyncio.as_completed(tasks):  # 完成一个 print一个
        result = await task
        print(result)

if __name__ == &apos;__main__&apos;:
    start_time = time.time()
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    print(&apos;last time:{}&apos;.format(time.time() - start_time))</code></pre><p>asyncio协程和之前讲解的select事件循环原理是一样的</p>
<h3 id="梳理-3"><a href="#梳理-3" class="headerlink" title="梳理"></a>梳理</h3><ol>
<li>协程中遇到必须要使用阻塞任务的时候，可以把阻塞代码放到线程池中运行</li>
<li>线程池中的代码放到loop.run_in_executor()里面，并且所有任务保存到列表</li>
<li>最后通过loop.run_until_complate(asyncio.wait(任务列表))中运行</li>
<li>asyncio能通过socket实现与服务端建立连接</li>
</ol>
<h2 id="与多进程的结合"><a href="#与多进程的结合" class="headerlink" title="与多进程的结合"></a>与多进程的结合</h2><p>既然异步协程和多进程对网络请求都有提升，那么为什么不把二者结合起来呢？在最新的 PyCon 2018 上，来自 Facebook 的 John Reese 介绍了 asyncio 和 multiprocessing 各自的特点，并开发了一个新的库，叫做 aiomultiprocess</p>
<p>这个库的安装方式是：</p>
<pre><code>pip3 install aiomultiprocess</code></pre><p>需要 Python 3.6 及更高版本才可使用。</p>
<p>使用这个库，我们可以将上面的例子改写如下：</p>
<pre><code>import asyncio
import aiohttp
import time
from aiomultiprocess import Pool

start = time.time()

async def get(url):
    session = aiohttp.ClientSession()
    response = await session.get(url)
    result = await response.text()
    session.close()
    return result

async def request():
    url = &apos;http://127.0.0.1:5000&apos;
    urls = [url for _ in range(100)]
    async with Pool() as pool:
        result = await pool.map(get, urls)
        return result

coroutine = request()
task = asyncio.ensure_future(coroutine)
loop = asyncio.get_event_loop()
loop.run_until_complete(task)

end = time.time()
print(&apos;Cost time:&apos;, end - start)</code></pre><p>这样就会同时使用多进程和异步协程进行请求，但在真实情况下，我们在做爬取的时候遇到的情况千变万化，一方面我们使用异步协程来防止阻塞，另一方面我们使用 multiprocessing 来利用多核成倍加速，节省时间其实还是非常可观的。</p>
<h2 id="同步与通信"><a href="#同步与通信" class="headerlink" title="同步与通信"></a>同步与通信</h2><p>和多线程多进程任务一样，协程也可以实现和需要进行同步与通信。</p>
<h3 id="简单例子-顺序启动多任务"><a href="#简单例子-顺序启动多任务" class="headerlink" title="简单例子(顺序启动多任务)"></a>简单例子(顺序启动多任务)</h3><p>协程是单线程的，他的执行依赖于事件循环中最后的loop.run_until_complate()</p>
<pre><code>import asyncio

num = 0

async def add():
    global num
    for i in range(10):
        await asyncio.sleep(0.1)
        num += i
async def desc():
    global num
    for i in range(10):
        await asyncio.sleep(0.2)
        num -= i

if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    tasks = [add(),desc()]
    loop.run_until_complete(asyncio.wait(tasks))
    # 这里执行顺序是先执行add函数，然后执行desc函数
    # 所以最后的结果是0
    loop.close()
    print(num)</code></pre><p>返回结果：</p>
<pre><code>0</code></pre><p>这里使用一个共有变量，协程下不需要加锁。</p>
<h3 id="简单例子-Lock-锁"><a href="#简单例子-Lock-锁" class="headerlink" title="简单例子(Lock(锁))"></a>简单例子(Lock(锁))</h3><pre><code># -*- coding:utf-8 -*-
import asyncio
import functools


def unlock(lock):
    print(&apos;线程锁释放成功&apos;)
    lock.release()


async def test(locker, lock):
    print(f&apos;{locker} 等待线程锁释放&apos;)
    # ---------------------------------
    # with await lock:
    #     print(f&apos;{locker} 线程锁上锁&apos;)
    # ---------------------------------
    # 上面这两行代码等同于：
    # ---------------------------------
    # await lock.acquire()
    # print(f&apos;{locker} 线程锁上锁&apos;)
    # lock.release()
    # ---------------------------------
    await lock.acquire()
    print(f&apos;{locker} 线程锁上锁&apos;)
    lock.release()
    print(f&apos;{locker} 线程锁释放&apos;)


async def main(loop):
    lock = asyncio.Lock()
    await lock.acquire()
    loop.call_later(0.5, functools.partial(unlock, lock))
    # call_later() 表达推迟一段时间的回调, 第一个参数是以秒为单位的延迟, 第二个参数是回调函数
    await asyncio.wait([test(&apos;任务 1 &apos;, lock), test(&apos;任务 2&apos;, lock)])


if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main(loop))
    loop.close()</code></pre><p>返回结果:</p>
<pre><code>任务 1  等待线程锁释放
任务 2 等待线程锁释放
线程锁释放成功
任务 1  线程锁上锁
任务 1  线程锁释放
任务 2 线程锁上锁
任务 2 线程锁释放</code></pre><h3 id="简单例子-Semaphore-信号量"><a href="#简单例子-Semaphore-信号量" class="headerlink" title="简单例子(Semaphore(信号量))"></a>简单例子(Semaphore(信号量))</h3><p>可以使用 Semaphore(信号量) 来控制并发访问的数量:</p>
<pre><code>import asyncio
from aiohttp import ClientSession


async def fetch(sem,url):
    async with sem:
        # 最大访问数
        async with ClientSession() as session:
            async with session.get(url) as response:
                    status = response.status
                    res = await response.text()
                    print(&quot;{}:{} &quot;.format(response.url, status))
                    return res

if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    url = &quot;https://sxadmin.github.io&quot;
    sem = asyncio.Semaphore(1000)
    # 设置最大并发数为1000
    tasks = [loop.create_task(fetch(sem,url))for i in range(100)]
    # 对网站访问100次
    loop.run_until_complete(asyncio.wait(tasks))</code></pre><h3 id="简单例子-Condition-条件"><a href="#简单例子-Condition-条件" class="headerlink" title="简单例子(Condition(条件))"></a>简单例子(Condition(条件))</h3><pre><code>import asyncio


async def consumer(cond, name, second):
    # 消费者函数
    await asyncio.sleep(second)
    # 等待延迟
    with await cond:
        await cond.wait()
        print(&apos;{}: 得到响应&apos;.format(name))


async def producer(cond):
    await asyncio.sleep(2)
    for n in range(1, 3):
        with await cond:
            print(&apos;生产者 {} 号&apos;.format(n))
            cond.notify(n=n) # 挨个通知单个消费者
        await asyncio.sleep(0.1)


async def producer2(cond):
    await asyncio.sleep(2)
    with await cond:
        print(&apos;释放信号量，通知所有消费者&apos;)
        cond.notify_all()
        # 一次性通知全部的消费者


async def main(loop):
    condition = asyncio.Condition()
    # 设置信号量
    task = loop.create_task(producer(condition))
    # producer 和 producer2 是两个协程, 不能使用 call_later(), 需要用到 create_task() 把它们创建成一个 task
    consumers = [consumer(condition, name, index) for index, name in enumerate((&apos;c1&apos;, &apos;c2&apos;))]
    await asyncio.wait(consumers)
    task.cancel()
    print(&apos;---分割线---&apos;)
    task = loop.create_task(producer2(condition))
    consumers = [consumer(condition, name, index) for index, name in enumerate((&apos;c1&apos;, &apos;c2&apos;))]
    await asyncio.wait(consumers)
    task.cancel()
    # 取消任务


if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main(loop))
    loop.close()</code></pre><p>返回结果：</p>
<pre><code>生产者 1 号
c1: 得到响应
生产者 2 号
c2: 得到响应
---分割线---
释放信号量，通知所有消费者
c1: 得到响应
c2: 得到响应</code></pre><h3 id="简单例子-Event-事件"><a href="#简单例子-Event-事件" class="headerlink" title="简单例子(Event(事件))"></a>简单例子(Event(事件))</h3><p>与 Lock(锁) 不同的是, 事件被触发的时候, 两个消费者不用获取锁, 就要尽快地执行下去了</p>
<pre><code>import asyncio
import functools


def set_event(event):
    print(&apos;开始设置事件&apos;)
    event.set()


async def test(name, event):
    print(&apos;{} 的事件未设置&apos;.format(name))
    await event.wait()
    print(&apos;{} 的事件已设置&apos;.format(name))


async def main(loop):
    event = asyncio.Event()
    # 声明事件
    print(&apos;事件是否设置: {}&apos;.format(event.is_set()))
    loop.call_later(0.1, functools.partial(set_event, event))
    # 在0.1s后执行set_event()函数，对事件进行设置
    await asyncio.wait([test(&apos;e1&apos;, event), test(&apos;e2&apos;, event)])
    print(&apos;最终事件状态: {}&apos;.format(event.is_set()))


if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main(loop))
    loop.close()</code></pre><p>返回结果：</p>
<pre><code>事件是否设置: False
e1 的事件未设置
e2 的事件未设置
开始设置事件
e1 的事件已设置
e2 的事件已设置
最终事件状态: True</code></pre><h3 id="简单例子-协程间通信"><a href="#简单例子-协程间通信" class="headerlink" title="简单例子(协程间通信)"></a>简单例子(协程间通信)</h3><p>协程是单线程，因此使用list、dict就可以实现通信，而不会有线程安全问题，当然可以使用asyncio.Queue</p>
<pre><code>from asyncio import Queue
queue = Queue(maxsize=3)   
# queue的put和get需要用await</code></pre><p>举个例子：</p>
<pre><code>import asyncio
from asyncio import Queue
import random
import string
q = Queue(maxsize=100)

async def add():
    while 1:
        await q.put(random.choice(string.ascii_letters))

async def desc():
    while 1:
        res = await q.get()
        print(res)
        await asyncio.sleep(1)

if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(asyncio.wait([add(),desc()]))
    loop.run_forever()</code></pre><p>返回结果:</p>
<pre><code>D
b
S
x
...</code></pre><h2 id="加速asyncio"><a href="#加速asyncio" class="headerlink" title="加速asyncio"></a>加速asyncio</h2><p>uvloop，这个使用库可以有效的加速asyncio，本库基于libuv，也就是nodejs用的那个库。使用它也非常方便，不过目前不支持windows</p>
<pre><code>import asyncio
import uvloop
asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</code></pre><p>没错就是2行代码，就可以提速asyncio。</p>
<p>tokio同样可以做异步资源循环</p>
<pre><code>import tokio
asyncio.set_event_loop_policy(tokio.EventLoopPolicy())</code></pre><h1 id="Aiohttp"><a href="#Aiohttp" class="headerlink" title="Aiohttp"></a>Aiohttp</h1><p>aiohttp是异步非阻塞的http请求库，结合协程一起才能在web请求发挥出极大的优势。</p>
<h2 id="aiohttp基础用法"><a href="#aiohttp基础用法" class="headerlink" title="aiohttp基础用法"></a>aiohttp基础用法</h2><p>aiohttp分为服务器端和客户端，本文只介绍客户端。</p>
<p>案例：</p>
<pre><code>import aiohttp
async def job(session):
    response = await session.get(URL)       # 等待并切换
    return str(response.url)


async def main(loop):
    async with aiohttp.ClientSession() as session:      # 官网推荐建立 Session 的形式
        tasks = [loop.create_task(job(session)) for _ in range(2)]
        finished, unfinished = await asyncio.wait(tasks)
        all_results = [r.result() for r in finished]    # 获取所有结果
        print(all_results)

t1 = time.time()
loop = asyncio.get_event_loop()
loop.run_until_complete(main(loop))
loop.close()
print(&quot;Async total time:&quot;, time.time() - t1)

&quot;&quot;&quot;
[&apos;https://morvanzhou.github.io/&apos;, &apos;https://morvanzhou.github.io/&apos;]
Async total time: 0.11447715759277344
&quot;&quot;&quot;</code></pre><p>我们刚刚创建了一个 Session, 这是官网推荐的方式, 但是我觉得也可以直接用 request 形式, 细节请参考官方说明. 如果要获取网页返回的结果, 我们可以在 job() 中 return 个结果出来, 然后再在 finished, unfinished = await asyncio.wait(tasks) 收集完成的结果, 这里它会返回完成的和没完成的, 我们关心的都是完成的, 而且 await 也确实是等待都完成了才返回. 真正的结果被存放在了 result() 里面.</p>
<h2 id="aiohttp安装"><a href="#aiohttp安装" class="headerlink" title="aiohttp安装"></a>aiohttp安装</h2><pre><code>pip3 install aiohttp</code></pre><h2 id="基本请求用法"><a href="#基本请求用法" class="headerlink" title="基本请求用法"></a>基本请求用法</h2><pre><code>async with aiohttp.get(&apos;https://github.com&apos;) as r:
        await r.text()</code></pre><p>其中r.text(), 可以在括号中指定解码方式，编码方式，例如</p>
<pre><code>await resp.text(encoding=&apos;windows-1251&apos;)</code></pre><p>或者也可以选择不编码，适合读取图像等，是无法编码的</p>
<pre><code>await resp.read()</code></pre><h2 id="发起一个session请求"><a href="#发起一个session请求" class="headerlink" title="发起一个session请求"></a>发起一个session请求</h2><p>首先是导入aiohttp模块：</p>
<pre><code>import aiohttp</code></pre><p>然后我们试着获取一个web源码，这里以GitHub的公共Time-line页面为例:</p>
<pre><code>async with aiohttp.ClientSession() as session:
    async with session.get(&apos;https://api.github.com/events&apos;) as resp:
        print(resp.status)
        print(await resp.text())</code></pre><p>上面的代码中，我们创建了一个 ClientSession 对象命名为session，然后通过session的get方法得到一个 ClientResponse 对象，命名为resp，get方法中传入了一个必须的参数url，就是要获得源码的http url。至此便通过协程完成了一个异步IO的get请求。<br>有get请求当然有post请求，并且post请求也是一个协程：</p>
<pre><code>session.post(&apos;http://httpbin.org/post&apos;, data=b&apos;data&apos;)</code></pre><p>用法和get是一样的，区别是post需要一个额外的参数data，即是需要post的数据。<br>除了get和post请求外，其他http的操作方法也是一样的：</p>
<pre><code>session.put(&apos;http://httpbin.org/put&apos;, data=b&apos;data&apos;)
session.delete(&apos;http://httpbin.org/delete&apos;)
session.head(&apos;http://httpbin.org/get&apos;)
session.options(&apos;http://httpbin.org/get&apos;)
session.patch(&apos;http://httpbin.org/patch&apos;, data=b&apos;data&apos;)</code></pre><p>小记：<br>不要为每次的连接都创建一次session,一般情况下只需要创建一个session，然后使用这个session执行所有的请求。</p>
<p>每个session对象，内部包含了一个连接池，并且将会保持连接和连接复用（默认开启）可以加快整体的性能。</p>
<h2 id="在URL中传递参数"><a href="#在URL中传递参数" class="headerlink" title="在URL中传递参数"></a>在URL中传递参数</h2><p>我们经常需要通过 get 在url中传递一些参数，参数将会作为url问号后面的一部分发给服务器。在aiohttp的请求中，允许以dict的形式来表示问号后的参数。举个例子，如果你想传递 key1=value1   key2=value2 到 httpbin.org/get 你可以使用下面的代码：</p>
<pre><code>params = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;}
async with session.get(&apos;http://httpbin.org/get&apos;,
                       params=params) as resp:
                       assert resp.url == &apos;http://httpbin.org/get?key2=value2&amp;key1=value1&apos;</code></pre><p>可以看到，代码正确的执行了，说明参数被正确的传递了进去。不管是一个参数两个参数，还是更多的参数，都可以通过这种方式来传递。除了这种方式之外，还有另外一个，使用一个 list 来传递（这种方式可以传递一些特殊的参数，例如下面两个key是相等的也可以正确传递）：</p>
<pre><code>params = [(&apos;key&apos;, &apos;value1&apos;), (&apos;key&apos;, &apos;value2&apos;)]
async with session.get(&apos;http://httpbin.org/get&apos;,
                       params=params) as r:
    assert r.url == &apos;http://httpbin.org/get?key=value2&amp;key=value1&apos;</code></pre><p>除了上面两种，我们也可以直接通过传递字符串作为参数来传递，但是需要注意，通过字符串传递的特殊字符不会被编码：</p>
<pre><code>async with session.get(&apos;http://httpbin.org/get&apos;,
                       params=&apos;key=value+1&apos;) as r:
        assert r.url == &apos;http://httpbin.org/get?key=value+1&apos;</code></pre><h2 id="响应的内容"><a href="#响应的内容" class="headerlink" title="响应的内容"></a>响应的内容</h2><p>还是以GitHub的公共Time-line页面为例，我们可以获得页面响应的内容：</p>
<pre><code>async with session.get(&apos;https://api.github.com/events&apos;) as resp:
    print(await resp.text())</code></pre><p>运行之后，会打印出类似于如下的内容：</p>
<pre><code>&apos;[{&quot;created_at&quot;:&quot;2015-06-12T14:06:22Z&quot;,&quot;public&quot;:true,&quot;actor&quot;:{...</code></pre><p>resp的text方法，会自动将服务器端返回的内容进行解码–decode，当然我们也可以自定义编码方式：</p>
<pre><code>await resp.text(encoding=&apos;gb2312&apos;)</code></pre><p>除了text方法可以返回解码后的内容外，我们也可以得到类型是字节的内容：</p>
<pre><code>print(await resp.read())</code></pre><p>运行的结果是：</p>
<pre><code>b&apos;[{&quot;created_at&quot;:&quot;2015-06-12T14:06:22Z&quot;,&quot;public&quot;:true,&quot;actor&quot;:{...</code></pre><p>gzip和deflate转换编码已经为你自动解码。</p>
<p>小记：</p>
<p>text(),read()方法是把整个响应体读入内存，如果你是获取大量的数据，请考虑使用”字节流“（streaming response）</p>
<h2 id="特殊响应内容：json"><a href="#特殊响应内容：json" class="headerlink" title="特殊响应内容：json"></a>特殊响应内容：json</h2><p>如果我们获取的页面的响应内容是json，aiohttp内置了更好的方法来处理json:</p>
<pre><code>async with session.get(&apos;https://api.github.com/events&apos;) as resp:
    print(await resp.json())</code></pre><p>如果因为某种原因而导致resp.json()解析json失败，例如返回不是json字符串等等，那么resp.json()将抛出一个错误，也可以给json()方法指定一个解码方式：</p>
<pre><code>print(await resp.json(
encoding=&apos;gb2312&apos;)) </code></pre><p>或者传递一个函数进去：</p>
<pre><code>print(await resp.json( lambda(x:x.replace(&apos;a&apos;,&apos;b&apos;)) ))</code></pre><h2 id="以字节流的方式读取响应内容"><a href="#以字节流的方式读取响应内容" class="headerlink" title="以字节流的方式读取响应内容"></a>以字节流的方式读取响应内容</h2><p>虽然json(),text(),read()很方便的能把响应的数据读入到内存，但是我们仍然应该谨慎的使用它们，因为它们是把整个的响应体全部读入了内存。即使你只是想下载几个字节大小的文件，但这些方法却将在内存中加载所有的数据。所以我们可以通过控制字节数来控制读入内存的响应内容：</p>
<pre><code>async with session.get(&apos;https://api.github.com/events&apos;) as resp:
    await resp.content.read(10) #读取前10个字节</code></pre><p>一般地，我们应该使用以下的模式来把读取的字节流保存到文件中：</p>
<pre><code>with open(filename, &apos;wb&apos;) as fd:
    while True:
        chunk = await resp.content.read(chunk_size)
        if not chunk:
            break
        fd.write(chunk)</code></pre><h2 id="自定义请求头"><a href="#自定义请求头" class="headerlink" title="自定义请求头"></a>自定义请求头</h2><p>如果你想添加请求头，可以像get添加参数那样以dict的形式，作为get或者post的参数进行请求：</p>
<pre><code>import json
url = &apos;https://api.github.com/some/endpoint&apos;
payload = {&apos;some&apos;: &apos;data&apos;}
headers = {&apos;content-type&apos;: &apos;application/json&apos;}

await session.post(url,
                   data=json.dumps(payload),
                   headers=headers)</code></pre><h2 id="自定义Cookie"><a href="#自定义Cookie" class="headerlink" title="自定义Cookie"></a>自定义Cookie</h2><p>给服务器发送cookie，可以通过给 ClientSession 传递一个cookie参数：</p>
<pre><code>url = &apos;http://httpbin.org/cookies&apos;
cookies = {&apos;cookies_are&apos;: &apos;working&apos;}
async with ClientSession(cookies=cookies) as session:
    async with session.get(url) as resp:
        assert await resp.json() == {
           &quot;cookies&quot;: {&quot;cookies_are&quot;: &quot;working&quot;}}</code></pre><p>可直接访问链接 “httpbin.org/cookies”查看当前cookie，访问session中的cookie请见第10节。</p>
<h2 id="忽略SSL证书"><a href="#忽略SSL证书" class="headerlink" title="忽略SSL证书"></a>忽略SSL证书</h2><p>在requests中，通过设置verify=False来忽略，在aiohttp中，这么设置即可：</p>
<pre><code>async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(verify_ssl=False)) as session:
    async session.get(url) as resp:
        pass</code></pre><p>禁止跳转也是在相同的位置设置</p>
<pre><code>allow_redirects = False</code></pre><h2 id="SSL加密请求"><a href="#SSL加密请求" class="headerlink" title="SSL加密请求"></a>SSL加密请求</h2><p>有的请求需要验证加密证书，可以设置ssl=False，取消验证</p>
<pre><code>r = await session.get(&apos;https://example.com&apos;, ssl=False)</code></pre><p>加入证书</p>
<pre><code>sslcontext = ssl.create_default_context(
   cafile=&apos;/path/to/ca-bundle.crt&apos;)
r = await session.get(&apos;https://example.com&apos;, ssl=sslcontext)</code></pre><h2 id="限制同时请求数量"><a href="#限制同时请求数量" class="headerlink" title="限制同时请求数量"></a>限制同时请求数量</h2><p>imit默认是100，limit=0的时候是无限制</p>
<pre><code>conn = aiohttp.TCPConnector(limit=30)</code></pre><h2 id="post数据的几种方式"><a href="#post数据的几种方式" class="headerlink" title="post数据的几种方式"></a>post数据的几种方式</h2><p>（1）模拟表单post数据</p>
<pre><code>payload = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;}
async with session.post(&apos;http://httpbin.org/post&apos;,data=payload) as resp:
    print(await resp.text())</code></pre><p>注意：data=dict的方式post的数据将被转码，和form提交数据是一样的作用，如果你不想被转码，可以直接以字符串的形式 data=str 提交，这样就不会被转码。</p>
<p>（2）post json</p>
<pre><code>import json
url = &apos;https://api.github.com/some/endpoint&apos;
payload = {&apos;some&apos;: &apos;data&apos;}

async with session.post(url, data=json.dumps(payload)) as resp:
    ...</code></pre><p>其实json.dumps(payload)返回的也是一个字符串，只不过这个字符串可以被识别为json格式</p>
<p>（3）post 小文件</p>
<pre><code>url = &apos;http://httpbin.org/post&apos;
files = {&apos;file&apos;: open(&apos;report.xls&apos;, &apos;rb&apos;)}

await session.post(url, data=files)
可以设置好文件名和content-type:
url = &apos;http://httpbin.org/post&apos;
data = FormData()
data.add_field(&apos;file&apos;,
               open(&apos;report.xls&apos;, &apos;rb&apos;),
               filename=&apos;report.xls&apos;,
               content_type=&apos;application/vnd.ms-excel&apos;)

await session.post(url, data=data)</code></pre><p>如果将文件对象设置为数据参数，aiohttp将自动以字节流的形式发送给服务器。</p>
<p>（4）post 大文件</p>
<p>aiohttp支持多种类型的文件以流媒体的形式上传，所以我们可以在文件未读入内存的情况下发送大文件。</p>
<pre><code>@aiohttp.streamer
def file_sender(writer, file_name=None):
    with open(file_name, &apos;rb&apos;) as f:
        chunk = f.read(2**16)
        while chunk:
            yield from writer.write(chunk)
            chunk = f.read(2**16)

# Then you can use `file_sender` as a data provider:

async with session.post(&apos;http://httpbin.org/post&apos;,data=file_sender(file_name=&apos;huge_file&apos;)) as resp:
    print(await resp.text())</code></pre><p>同时我们可以从一个url获取文件后，直接post给另一个url，并计算hash值:</p>
<pre><code>async def feed_stream(resp, stream):
    h = hashlib.sha256()

    while True:
        chunk = await resp.content.readany()
        if not chunk:
            break
        h.update(chunk)
        stream.feed_data(chunk)

    return h.hexdigest()

resp = session.get(&apos;http://httpbin.org/post&apos;)
stream = StreamReader()
loop.create_task(session.post(&apos;http://httpbin.org/post&apos;, data=stream))
file_hash = await feed_stream(resp, stream)</code></pre><p>因为响应内容类型是StreamReader，所以可以把get和post连接起来，同时进行post和get：</p>
<pre><code>r = await session.get(&apos;http://python.org&apos;)
await session.post(&apos;http://httpbin.org/post&apos;,data=r.content)</code></pre><p>（5）post预压缩数据</p>
<p>在通过aiohttp发送前就已经压缩的数据, 调用压缩函数的函数名（通常是deflate 或 zlib）作为content-encoding的值：</p>
<pre><code>async def my_coroutine(session, headers, my_data):
    data = zlib.compress(my_data)
    headers = {&apos;Content-Encoding&apos;: &apos;deflate&apos;}
    async with session.post(&apos;http://httpbin.org/post&apos;,
                            data=data,
                            headers=headers)
        pass</code></pre><h2 id="keep-alive-连接池，共享cookie"><a href="#keep-alive-连接池，共享cookie" class="headerlink" title="keep-alive, 连接池，共享cookie"></a>keep-alive, 连接池，共享cookie</h2><p>ClientSession 用于在多个连接之间共享cookie：</p>
<pre><code>async with aiohttp.ClientSession() as session:
    await session.get(
        &apos;http://httpbin.org/cookies/set?my_cookie=my_value&apos;)
    filtered = session.cookie_jar.filter_cookies(&apos;http://httpbin.org&apos;)
    assert filtered[&apos;my_cookie&apos;].value == &apos;my_value&apos;
    async with session.get(&apos;http://httpbin.org/cookies&apos;) as r:
        json_body = await r.json()
        assert json_body[&apos;cookies&apos;][&apos;my_cookie&apos;] == &apos;my_value&apos;</code></pre><p>也可以为所有的连接设置共同的请求头：</p>
<pre><code>async with aiohttp.ClientSession(
    headers={&quot;Authorization&quot;: &quot;Basic bG9naW46cGFzcw==&quot;}) as session:
    async with session.get(&quot;http://httpbin.org/headers&quot;) as r:
        json_body = await r.json()
        assert json_body[&apos;headers&apos;][&apos;Authorization&apos;] == \
            &apos;Basic bG9naW46cGFzcw==&apos;</code></pre><p>ClientSession 还支持 keep-alive连接和连接池(connection pooling)</p>
<h2 id="cookie安全性"><a href="#cookie安全性" class="headerlink" title="cookie安全性"></a>cookie安全性</h2><p>默认ClientSession使用的是严格模式的 aiohttp.CookieJar. RFC 2109，明确的禁止接受url和ip地址产生的cookie，只能接受 DNS 解析IP产生的cookie。可以通过设置aiohttp.CookieJar 的 unsafe=True 来配置：</p>
<pre><code>jar = aiohttp.CookieJar(unsafe=True)
session = aiohttp.ClientSession(cookie_jar=jar)</code></pre><h2 id="控制同时连接的数量（连接池）"><a href="#控制同时连接的数量（连接池）" class="headerlink" title="控制同时连接的数量（连接池）"></a>控制同时连接的数量（连接池）</h2><p>也可以理解为同时请求的数量，为了限制同时打开的连接数量，我们可以将限制参数传递给连接器：</p>
<pre><code>conn = aiohttp.TCPConnector(limit=30)#同时最大进行连接的连接数为30，默认是100，limit=0的时候是无限制</code></pre><p>限制同时打开限制同时打开连接到同一端点的数量（(host, port, is_ssl) 三的倍数），可以通过设置 limit_per_host 参数：</p>
<pre><code>conn = aiohttp.TCPConnector(limit_per_host=30)#默认是0</code></pre><h2 id="自定义域名解析"><a href="#自定义域名解析" class="headerlink" title="自定义域名解析"></a>自定义域名解析</h2><p>我们可以指定域名服务器的 IP 对我们提供的get或post的url进行解析：</p>
<pre><code>from aiohttp.resolver import AsyncResolver
resolver = AsyncResolver(nameservers=[&quot;8.8.8.8&quot;, &quot;8.8.4.4&quot;])
conn = aiohttp.TCPConnector(resolver=resolver)</code></pre><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>aiohttp支持使用代理来访问网页：</p>
<pre><code>async with aiohttp.ClientSession() as session:
    async with session.get(&quot;http://python.org&quot;,
                           proxy=&quot;http://some.proxy.com&quot;) as resp:
        print(resp.status)</code></pre><p>当然也支持需要授权的页面：</p>
<pre><code>async with aiohttp.ClientSession() as session:
    proxy_auth = aiohttp.BasicAuth(&apos;user&apos;, &apos;pass&apos;)
    async with session.get(&quot;http://python.org&quot;,proxy=&quot;http://some.proxy.com&quot;,proxy_auth=proxy_auth) as resp:
        print(resp.status)</code></pre><p>或者通过这种方式来验证授权：</p>
<pre><code>session.get(&quot;http://python.org&quot;,proxy=&quot;http://user:pass@some.proxy.com&quot;)</code></pre><h2 id="响应状态码-response-status-code"><a href="#响应状态码-response-status-code" class="headerlink" title="响应状态码 response status code"></a>响应状态码 response status code</h2><p>可以通过 resp.status来检查状态码是不是200：</p>
<pre><code>async with session.get(&apos;http://httpbin.org/get&apos;) as resp:
    assert resp.status == 200</code></pre><h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><p>我们可以直接使用　resp.headers 来查看响应头，得到的值类型是一个dict：</p>
<pre><code>&gt;&gt;&gt; resp.headers
{&apos;ACCESS-CONTROL-ALLOW-ORIGIN&apos;: &apos;*&apos;,
 &apos;CONTENT-TYPE&apos;: &apos;application/json&apos;,
 &apos;DATE&apos;: &apos;Tue, 15 Jul 2014 16:49:51 GMT&apos;,
 &apos;SERVER&apos;: &apos;gunicorn/18.0&apos;,
 &apos;CONTENT-LENGTH&apos;: &apos;331&apos;,
 &apos;CONNECTION&apos;: &apos;keep-alive&apos;}</code></pre><p>或者我们可以查看原生的响应头：</p>
<pre><code>&gt;&gt;&gt; resp.raw_headers
((b&apos;SERVER&apos;, b&apos;nginx&apos;),
 (b&apos;DATE&apos;, b&apos;Sat, 09 Jan 2016 20:28:40 GMT&apos;),
 (b&apos;CONTENT-TYPE&apos;, b&apos;text/html; charset=utf-8&apos;),
 (b&apos;CONTENT-LENGTH&apos;, b&apos;12150&apos;),
 (b&apos;CONNECTION&apos;, b&apos;keep-alive&apos;))</code></pre><h2 id="重定向的响应头"><a href="#重定向的响应头" class="headerlink" title="重定向的响应头"></a>重定向的响应头</h2><p>如果一个请求被重定向了，我们依然可以查看被重定向之前的响应头信息：</p>
<pre><code>&gt;&gt;&gt; resp = await session.get(&apos;http://example.com/some/redirect/&apos;)
&gt;&gt;&gt; resp
&lt;ClientResponse(http://example.com/some/other/url/) [200]&gt;
&gt;&gt;&gt; resp.history
(&lt;ClientResponse(http://example.com/some/redirect/) [301]&gt;,)</code></pre><h2 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h2><p>默认的IO操作都有5分钟的响应时间 我们可以通过 timeout 进行重写：</p>
<pre><code>async with session.get(&apos;https://github.com&apos;, timeout=60) as r:
    ...</code></pre><h1 id="其他优秀的AIO库"><a href="#其他优秀的AIO库" class="headerlink" title="其他优秀的AIO库"></a>其他优秀的AIO库</h1><h2 id="aio-mysql"><a href="#aio-mysql" class="headerlink" title="aio_mysql"></a>aio_mysql</h2><p>支持mysql异步连接</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ol>
<li>python3.4+</li>
<li>mysql环境</li>
<li>asyncio</li>
<li>aiomysql</li>
</ol>
<h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><pre><code>import asyncio
from aiomysql import create_pool
# 导入创建数据库连接
loop = asyncio.get_event_loop()
# 创建一个事件循环

async def go():
    async with create_pool(host=&apos;127.0.0.1&apos;, port=3306,user=&apos;root&apos;,password=&apos;root&apos;,db=&apos;mysql&apos;, loop=loop) as pool:
    # 请求连接到数据库
        async with pool.get() as conn:
        # 获取到数据库连接的游标
            async with conn.cursor() as cur:
            # 操作sql数据库
                await cur.execute(&quot;show databases;&quot;)
                # 获取结果事件，此时用await等待
                value = await cur.fetchall()
                # 等待获取结果
                print(value)
loop.run_until_complete(go())</code></pre><p>返回结果：</p>
<pre><code>((&apos;information_schema&apos;,), (&apos;challenges&apos;,), (&apos;mysql&apos;,), (&apos;nikes&apos;,), (&apos;performance_schema&apos;,), (&apos;security&apos;,), (&apos;test&apos;,), (&apos;url&apos;,), (&apos;yolanda_information_collection_099&apos;,))</code></pre><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><pre><code>import asyncio
import aiomysql

async def test_example(loop):
    pool = await aiomysql.create_pool(host=&apos;127.0.0.1&apos;, port=3306,user=&apos;root&apos;, password=&apos;root&apos;,db=&apos;mysql&apos;, loop=loop)
    # 定义创建一个mysql连接池
    async with pool.acquire() as conn:
    # 每次请求操作sql数据库的时候都要上锁，保证线程安全
        async with conn.cursor() as cur:
        # 操作sql数据库
            await cur.execute(&quot;show databases;&quot;)
            # 等待获取哦结果
            print(cur.description)
            r = await cur.fetchone()
            # 等待获取结果
            print (r)
    pool.close()
    await pool.wait_closed()

loop = asyncio.get_event_loop()
loop.run_until_complete(test_example(loop))</code></pre><p>返回结果：</p>
<pre><code>((&apos;Database&apos;, 253, None, 256, 256, 0, False),)
(&apos;information_schema&apos;,)</code></pre><h2 id="aioredis"><a href="#aioredis" class="headerlink" title="aioredis"></a>aioredis</h2><p>支持redis异步连接</p>
<h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><ol>
<li>python3.5+</li>
<li>hiredis</li>
<li>redis数据库环境</li>
</ol>
<h3 id="基础用法-1"><a href="#基础用法-1" class="headerlink" title="基础用法"></a>基础用法</h3><pre><code>import asyncio
import aioredis

loop = asyncio.get_event_loop()

async def go():
    conn = await aioredis.create_connection(&apos;redis://localhost&apos;, loop=loop)
    # 等待连接redis数据库
    await conn.execute(&apos;set&apos;, &apos;my-key&apos;, &apos;value&apos;)
    # 等待执行查询语句
    val = await conn.execute(&apos;get&apos;, &apos;my-key&apos;)
    # 等待获取结果
    print(val)
    conn.close()
    # 关闭连接
    await conn.wait_closed()
    # 必须要等待关闭数据库连接
loop.run_until_complete(go())</code></pre><p>当然还有另一种写法也能达到同样的效果：</p>
<pre><code>import asyncio
import aioredis

loop = asyncio.get_event_loop()

async def go():
    redis = await aioredis.create_redis(
        &apos;redis://localhost&apos;, loop=loop)
    await redis.set(&apos;my-key&apos;, &apos;value&apos;)
    val = await redis.get(&apos;my-key&apos;)
    print(val)
    redis.close()
    await redis.wait_closed()
loop.run_until_complete(go())</code></pre><h3 id="连接池-1"><a href="#连接池-1" class="headerlink" title="连接池"></a>连接池</h3><pre><code>import asyncio
import aioredis

loop = asyncio.get_event_loop()

async def go():
    pool = await aioredis.create_pool(
        &apos;redis://localhost&apos;,
        minsize=5, maxsize=10,
        loop=loop)
    # 创建连接池，设置最大和最小连接数
    await pool.execute(&apos;set&apos;, &apos;my-key&apos;, &apos;value&apos;)
    # 等待执行查询语句
    print(await pool.execute(&apos;get&apos;, &apos;my-key&apos;))
    pool.close()
    # 关闭连接池
    await pool.wait_closed()
    # 别忘了等待让所有连接池关闭

loop.run_until_complete(go())</code></pre><p>当然连接池还有另一种写法，功能一致：</p>
<pre><code>import asyncio
import aioredis

loop = asyncio.get_event_loop()

async def go():
    redis = await aioredis.create_redis_pool(
        &apos;redis://localhost&apos;,
        minsize=5, maxsize=10,
        loop=loop)
    await redis.set(&apos;my-key&apos;, &apos;value&apos;)
    val = await redis.get(&apos;my-key&apos;)
    print(val)
    redis.close()
    await redis.wait_closed()
loop.run_until_complete(go())</code></pre><p><a href="https://aioredis.readthedocs.io/en/v1.2.0/" target="_blank" rel="noopener">aioredis 官方文档</a></p>
<h2 id="aiomultiprocess"><a href="#aiomultiprocess" class="headerlink" title="aiomultiprocess"></a>aiomultiprocess</h2><p>上文提起过，基于多进程与协程结合，可以发挥出多核CPU的优势，还有一个aiomultiprocessing的库，功能差不多，但是封装的不是太好，优化也没aiomultiprocess这个好。</p>
<h3 id="依赖-2"><a href="#依赖-2" class="headerlink" title="依赖"></a>依赖</h3><ol>
<li>python3.6+</li>
<li>asyncio</li>
<li>aiomultiprocess</li>
</ol>
<h3 id="基础用法-2"><a href="#基础用法-2" class="headerlink" title="基础用法"></a>基础用法</h3><pre><code>import asyncio
import aiomultiprocess
import aiohttp

async def get_url_info(url):
    # 这一部分就是发起网络请求，没有aiomultiprocess的参与
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            result = await resp.text()
            print(f&apos;{resp.url}:{resp.status}&apos;)

async def main():
    # main()函数是核心函数，负责给每个CPU提供任务
    p = aiomultiprocess.Process(target=get_url_info,args=(&apos;https://sxadmin.github.io&apos;,))
    # 传入参数
    await p
    # p是消耗事件的操作，需要使用await
if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    # 如果是python3.7的话，就直接使用asyncio.run(mian())即可</code></pre><p>返回结果：</p>
<pre><code>https://sxadmin.github.io:200</code></pre><p>如果是传入一个网址列表的话：</p>
<pre><code>async def main():
    # main()函数是核心函数，负责给每个CPU提供任务
    tasks = [&apos;https://sxadmin.github.io&apos; for i in range(10)]
    # tasks列表有10个网址
    for url in tasks:
        p = aiomultiprocess.Process(target=get_url_info,args=(url,))
    # 传入参数
        await p
    # p是消耗事件的操作，需要使用await
if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    # 如果是python3.7的话，就直接使用asyncio.run(mian())即可</code></pre><h3 id="获取返回结果"><a href="#获取返回结果" class="headerlink" title="获取返回结果"></a>获取返回结果</h3><pre><code># -*- coding:utf-8 -*-
import asyncio
import aiomultiprocess
import aiohttp

async def get_url_info(url):
    # 这一部分就是发起网络请求，没有aiomultiprocess的参与
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            return await resp.text()
            #print(f&apos;{resp.url}:{resp.status}&apos;)

async def main():
    # main()函数是核心函数，负责给每个CPU提供任务
    p = aiomultiprocess.Worker(target=get_url_info,args=(&apos;https://sxadmin.github.io&apos;,))
    # 传入参数,这里用Worker
    res = await p
    print(res)
    # p是消耗事件的操作，需要使用await
if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    # 如果是python3.7的话，就直接使用asyncio.run(mian())即可</code></pre><p>返回结果：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html class=&quot;theme-next muse use-motion&quot; lang=&quot;zh-Hans&quot;&gt;
&lt;head&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo 3.8.0&quot;&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; c
....</code></pre><h3 id="线程池管理"><a href="#线程池管理" class="headerlink" title="线程池管理"></a>线程池管理</h3><pre><code># -*- coding:utf-8 -*-
import asyncio
import aiomultiprocess
import aiohttp

async def get_url_info(url):
    # 这一部分就是发起网络请求，没有aiomultiprocess的参与
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            return await resp.read()

async def main():
    # main()函数是核心函数，负责给每个CPU提供任务
    tasks = [&apos;https://sxadmin.github.io&apos; for i in range(10)]
    # 10个网址保存到列表

    async with aiomultiprocess.Pool() as pool:
        # 开启进程池
        result = await pool.map(get_url_info,tasks)
        # 这里必须要await，使用pool.map()方法
    print(result)
    # 返回的结果是一个列表

if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    # 如果是python3.7的话，就直接使用asyncio.run(mian())即可</code></pre><p>返回结果：</p>
<pre><code>[b&apos;&lt;!DOCTYPE html&gt;\n\n\n\n  \n\n\n&lt;html class=&quot;theme-next muse use.......</code></pre><p>线程池传递参数，设置CPU核心数和协程数量</p>
<pre><code>async with aiomultiprocess.Pool(processes=8, childconcurrency=16) as pool:</code></pre><p>如上设置8个进程，16个协程</p>
<h3 id="对传参控制"><a href="#对传参控制" class="headerlink" title="对传参控制"></a>对传参控制</h3><p>对传递的参数一个是列表，一个是单个的字符串，如何处理？</p>
<p>比如下面的代码：</p>
<pre><code>async def get_image(url:&apos;http://test.com/&apos;,dirs:&apos;[a.jpg,b.jpg,c.jpg]&apos;):
    async with aiohttp.ClientSession() as session:
        for dir in dirs:
            async with session.get(url=url+dir) as resp:
                if resp.status == 200:
                    return await resp.content()
                    # only need one exists image url
async def main(url,dirs):
    async with aiomultiprocess.Pool() as pool:
        result = await pool.map(get_image,??,??)
        # hao to set there?
    print(result)

if __name__ == &apos;__main__&apos;:
    urls = [&apos;http://1.com/&apos;,&apos;http://2.com/&apos;,&apos;http://3.com/&apos;,&apos;http://4.com/&apos;,]
    dirs = [&apos;a.jpg&apos;,&apos;b.jpg&apos;,&apos;c.jpg&apos;]
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main(urls,dirs))</code></pre><p>我想到办法是先申明dirs在最前面，然后作为全局变量不传递dirs。</p>
<p>解决方法是：</p>
<pre><code>dirs = [&apos;a.jpg&apos;, &apos;b.jpg&apos;, &apos;c.jpg&apos;]
async def get_image(url:&apos;http://test.com/&apos;):
    async with aiohttp.ClientSession() as session:
        for dir in dirs:
            print(url+dir)
            async with session.get(url=url+dir,timeout=3) as resp:
                if resp.status == 200:
                    return await resp.content()
                    # only need one exists image url

async def main():
    urls = urls = [&apos;http://1.com/&apos;,&apos;http://2.com/&apos;,&apos;http://3.com/&apos;,&apos;http://4.com/&apos;]
    async with aiomultiprocess.Pool() as pool:
        result = await pool.map(get_image,urls)
    print(result)

if __name__ == &apos;__main__&apos;:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())</code></pre><p>该库的作者jreese 告诉我可以使用pool.starmap()的方法来处理参数：</p>
<pre><code>async def get_image(url, dirs):
    ...

async def main():
    urls = [...]
    dirs = [...]
    async with Pool() as pool:
        result = await pool.starmap(get_image, ((url, dirs) for url in urls))</code></pre><p><a href="https://github.com/jreese/aiomultiprocess/issues/18#event-2288704842" target="_blank" rel="noopener">链接</a></p>
<h2 id="aiofiles"><a href="#aiofiles" class="headerlink" title="aiofiles"></a>aiofiles</h2><p>普通的本地文件IO是阻塞的，不能轻易地和可移植地使之成为异步的。这意味着执行文件IO可能会干扰异步IO应用程序，而异步应用程序不应阻塞执行线程。aiofiles通过引入支持将操作委托给单独线程池的文件的异步版本来帮助实现这一点。</p>
<h3 id="基础用法-3"><a href="#基础用法-3" class="headerlink" title="基础用法"></a>基础用法</h3><pre><code>import asyncio
import aiofiles

async def read_data():
    async with aiofiles.open(&apos;example.txt&apos;,mode=&apos;r&apos;,encoding=&apos;utf-8&apos;)as f:
    # 打开文件，等待读取
        content = await f.readlines()
        # 等待读取结果
        print(content)
loop = asyncio.get_event_loop()
loop.run_until_complete(read_data())</code></pre><p>当前目录下有example.txt文件</p>
<p>具有如下方法：</p>
<pre><code>close：关闭
flush：刷新
read：读取文件所有
readline：读取第一行，结果保存到列表
readlines：读取所有行，结果保存到列表
write：写入
writelines：接收参数是一个可迭代对象，写入</code></pre><h2 id="Aiodns"><a href="#Aiodns" class="headerlink" title="Aiodns"></a>Aiodns</h2><p>Aiodns是在dnspython后支持异步的dns库，一般可用于网址服务器搭建与子域名爆破(通过dns服务器获取数据结果)</p>
<p>本来想通过asyncio+aiomultiprocess+aiodns开发一款异步协程的子域名爆破工具，但是发现已经由蘑菇街的安全开发大佬写出来了，这里我就不重复造轮子了。<a href="https://github.com/FeeiCN/ESD" target="_blank" rel="noopener">基于异步协程的子域名爆破工具链接</a></p>
<p>这里是大佬的博客介绍<a href="https://feei.cn/esd" target="_blank" rel="noopener">地址</a></p>
<p>我拜读完代码后，发现大佬不仅基于字典做优化，还拓展了基于多种搜索引擎(百度，google，bing)和资产搜索引擎(zoomeye,shadon,fofa)的功能，使用uvloop加速，但是这样就只能在*inux系统下运行，如果想要在windows下运行，删除那两行vuloop的代码即可。</p>
<p>这个子域名爆破工具个人认为是目前最好用的。</p>
<h3 id="基础用法-4"><a href="#基础用法-4" class="headerlink" title="基础用法"></a>基础用法</h3><pre><code>import asyncio
import aiodns

loop = asyncio.get_event_loop()
resolver = aiodns.DNSResolver(loop=loop)
f = resolver.query(&apos;google.com&apos;,&apos;A&apos;)
result = loop.run_until_complete(f)
print(result)</code></pre><h2 id="AsyncSSH"><a href="#AsyncSSH" class="headerlink" title="AsyncSSH"></a>AsyncSSH</h2><p>Python3.4+AsyncIO框架之上提供了sshv2协议的异步客户机和服务器实现。</p>
<h3 id="依赖-3"><a href="#依赖-3" class="headerlink" title="依赖"></a>依赖</h3><ol>
<li>python3.4+</li>
<li>cryptography (PyCA) 2.6.1+</li>
</ol>
<h3 id="基础用法-5"><a href="#基础用法-5" class="headerlink" title="基础用法"></a>基础用法</h3><pre><code>import asyncio, asyncssh, sys

async def run_client():
    async with asyncssh.connect(&apos;localhost&apos;) as conn:
        result = await conn.run(&apos;echo &quot;Hello!&quot;&apos;, check=True)
        print(result.stdout, end=&apos;&apos;)

try:
    asyncio.get_event_loop().run_until_complete(run_client())
except (OSError, asyncssh.Error) as exc:
    sys.exit(&apos;SSH connection failed: &apos; + str(exc))</code></pre><h2 id="janus"><a href="#janus" class="headerlink" title="janus"></a>janus</h2><p>一个基于异步的线程安全消息队列，混合同步异步队列，应该用于经典同步（线程）代码和异步（异步）代码之间的通信。提供两个接口：同步和异步接口。同步与标准队列完全兼容，异步队列遵循异步队列设计。</p>
<h3 id="基础用法-6"><a href="#基础用法-6" class="headerlink" title="基础用法"></a>基础用法</h3><pre><code># -*- coding:utf-8 -*-
import asyncio
import janus
loop = asyncio.get_event_loop()
queue = janus.Queue(loop=loop)
# queue队列可以设置异步队列和同步队列
# queue.async_q:异步
# queue.sync_q:同步

def threaded(sync_q):
    # 这个函数接受的是同步的队列
    for i in range(10):
        sync_q.put(i)
        # 队列放入数据
    sync_q.join()
    # 等待所有数据存放完毕


async def async_coro(async_q):
    for i in range(10):
        val = await async_q.get()
        print(val)
        # assert val == i
        # 等同于 if val == i:
        if val == i:
            async_q.task_done()
            # 如果获取到了结尾的数字，就关闭这个消息队列


fut = loop.run_in_executor(None, threaded, queue.sync_q)
# 该方法是把阻塞的队列注册加载到loop中，等待完成
loop.run_until_complete(async_coro(queue.async_q))
# 执行async_coro()函数，传入的参数是 queue.async_q (queue队列的异步队列)
loop.run_until_complete(fut)
# 这行代码不要也行</code></pre><p>返回结果：</p>
<pre><code>0
1
2
3
4
5
6
7
8
9</code></pre><h2 id="aioelasticsearch"><a href="#aioelasticsearch" class="headerlink" title="aioelasticsearch"></a>aioelasticsearch</h2><p>支持Elasticsearch的异步库</p>
<h3 id="基础用法-7"><a href="#基础用法-7" class="headerlink" title="基础用法"></a>基础用法</h3><pre><code>import asyncio

from aioelasticsearch import Elasticsearch

async def go():
    es = Elasticsearch()

    print(await es.search())

    await es.close()

loop = asyncio.get_event_loop()
loop.run_until_complete(go())
loop.close()</code></pre><h3 id="异步滚动"><a href="#异步滚动" class="headerlink" title="异步滚动"></a>异步滚动</h3><pre><code>import asyncio

from aioelasticsearch import Elasticsearch
from aioelasticsearch.helpers import Scan

async def go():
    async with Elasticsearch() as es:
        async with Scan(
            es,
            index=&apos;index&apos;,
            doc_type=&apos;doc_type&apos;,
            query={},
        ) as scan:
            print(scan.total)

            async for doc in scan:
                print(doc[&apos;_source&apos;])

loop = asyncio.get_event_loop()
loop.run_until_complete(go())
loop.close()</code></pre><p><a href="https://blog.csdn.net/luanpeng825485697/article/details/81461277" target="_blank" rel="noopener">asyncio 异步</a></p>
<p><a href="https://blog.csdn.net/esabeny/article/details/81811515" target="_blank" rel="noopener">三种异步速度对比 </a></p>
<p><a href="https://www.jianshu.com/p/4f667ecae64f" target="_blank" rel="noopener">Python Asyncio 资源列表 1</a></p>
<p><a href="https://github.com/aio-libs" target="_blank" rel="noopener">Python Asyncio 资源列表 2</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Sxadmin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sxadmin.github.io/2019/04/03/Asyncio%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">https://sxadmin.github.io/2019/04/03/Asyncio%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sxadmin.github.io" target="_blank">Sxadmin blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Asyncio/">Asyncio</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/07/03/Django-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Django-快速上手</div></div></a></div><div class="next-post pull_right"><a href="/2019/03/07/Python%E6%89%93%E5%8C%85exe%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python打包exe文件方法</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Sxadmin</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>